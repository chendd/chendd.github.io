<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android_study | Chendd's Blog]]></title>
  <link href="http://chendd.github.io/blog/categories/android-study/atom.xml" rel="self"/>
  <link href="http://chendd.github.io/"/>
  <updated>2016-07-28T12:00:22+08:00</updated>
  <id>http://chendd.github.io/</id>
  <author>
    <name><![CDATA[chendd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android学习日记10--裁剪区域]]></title>
    <link href="http://chendd.github.io/blog/2014/02/28/android_study_10/"/>
    <updated>2014-02-28T22:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2014/02/28/android_study_10</id>
    <content type="html"><![CDATA[<h2>裁剪区域</h2>

<p>&#160; &#160; &#160; &#160;裁剪是画布的一个函数，区域可以是矩形和圆形，也可以通过设置 path 或Region来显示自定义区域，通过不同组合，Android几乎可以支持任意现状的裁剪区域。</p>

<p>&#160; &#160; &#160; &#160;android.graphics包中定义了Point, Rect, Path, Region 这几种几何形状，Path可以为有圆弧，椭圆，二次曲线，三次曲线，线段，矩形等基本几何图形或是由这些基本几何图形组合而成，Path可以为开放或是闭合曲线。Rect提供了定义矩形的简洁方法。</p>

<!--more-->


<pre><code class="java">//绘制一张背景图片，充满整个屏幕
Bitmap bitmap1 = BitmapFactory.decodeResource(this.getResources(), R.drawable.background);

canvas.save();
// 四个参数 表示左上角的坐标和宽高
canvas.clipRect(0, 0, 30, 30);        
canvas.drawBitmap(bitmap1, 0, 0, paint);
canvas.restore();


canvas.save();
Path path = new Path();
// 添加一个圆形区域 
path.addCircle(130, 130, 30, Direction.CCW);
// 也可以通过设置 path 来显示自定义区域
canvas.clipPath(path);
canvas.drawBitmap(bitmap1, 0, 0, paint);
canvas.restore();
</code></pre>

<p>效果如下：</p>

<p><img src="http://images.cnitblog.com/blog/602984/201402/252027498664351.jpg" alt="image" /></p>

<p>需注意的是 裁剪区域的函数是对 整个画布的操作
为了避免对其他绘制受到影响，需对画布save保存，裁剪完之后 restore复原</p>

<p>此外也可以通过Region来进行裁剪区域的划分 第三个参数比较复杂(在最后说明)</p>

<pre><code class="java">canvas.save();
Region region = new Region();
// op是添加区域的函数，最后一个参数表示显示的参数，有交并补差等等
region.op(new Rect(20,20,100,100), Region.Op.UNION);
region.op(new Rect(40,20,80,150), Region.Op.XOR);
canvas.clipRegion(region);
canvas.drawBitmap(bitmap1, 0, 0, paint);
canvas.restore();
</code></pre>

<p>效果如下：</p>

<p><img src="http://images.cnitblog.com/blog/602984/201402/252028493998838.jpg" alt="image" /></p>

<p>为了方便说明，把第一次clipRect的绘制范围设为A，第二次clipRect设定的范围设为B</p>

<ul>
<li>Op.DIFFERENCE，实际上就是求得的A和B的差集范围，即A－B，只有在此范围内的绘制内容才会被显示；</li>
<li>Op.REVERSE_DIFFERENCE，实际上就是求得的B和A的差集范围，即B－A，只有在此范围内的绘制内容才会被显示；；</li>
<li>Op.INTERSECT，即A和B的交集范围，只有在此范围内的绘制内容才会被显示；</li>
<li>Op.REPLACE，不论A和B的集合状况，B的范围将全部进行显示，如果和A有交集，则将覆盖A的交集范围；</li>
<li>Op.UNION，即A和B的并集范围，即两者所包括的范围的绘制内容都会被显示；</li>
<li>Op.XOR，A和B的补集范围，此例中即A除去B以外的范围，只有在此范围内的绘制内容才会被显示</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android学习日记9--BitMap操作]]></title>
    <link href="http://chendd.github.io/blog/2014/02/25/android_study_09/"/>
    <updated>2014-02-25T22:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2014/02/25/android_study_09</id>
    <content type="html"><![CDATA[<h2>Bitmap</h2>

<p>&#160; &#160; &#160; &#160;android里的图像处理重要的类，支持jpg、png、bmp等格式的图像，BitmapDrawable是封装Bitmap的一个对象，Bitmap实现在android.graphics包中。但是Bitmap类的构造函数是私有的，外面并不能实例化，只能是通过JNI(Java Native Interface JAVA本地调用)实例化。这必然是 某个辅助类提供了创建Bitmap的接口，而这个类的实现通过JNI接口来实例化Bitmap的，这个类就是BitmapFactory。利用BitmapFactory可以从一个指定文件中，利用decodeFile()解出Bitmap；也可以定义的图片资源中，利用decodeResource()解出Bitmap　　</p>

<!--more-->


<p>&#160; &#160; &#160; &#160;android支持一些方法对图像的平移、剪切、旋转、缩放等操作这样子可以用一张图片经过变化得到自己想要的，节省很多系统资源。</p>

<p>&#160; &#160; &#160; &#160;由于手机系统资源有限，没用的图像要及时回收，否则会产生OOM，isRecycled()判读该Bitmap是否可回收，recycle()强制Bitmap自我回收。</p>

<h4>1、android 系统图像的简单变化例子：</h4>

<pre><code class="java">// 获取图标图像的实例
Bitmap bitmap = BitmapFactory.decodeResource(this.getResources()
　　　　　　　　　　　　　　, R.drawable.ic_launcher);
// 绘制图像
canvas.drawBitmap(bitmap, 0, 0, paint);
// 保存当前状态
canvas.save();

// 绕图像中点旋转90度
canvas.rotate(30, bitmap.getWidth()/2, bitmap.getHeight()/2);
// 为了不重叠，画在(50,0)这点,x,y轴相对旋转也发生变化
canvas.drawBitmap(bitmap, 50, 0, paint);

//恢复上次保存的状态与save()对应
canvas.restore();
canvas.drawBitmap(bitmap, 100, 100, paint);

//平移
canvas.translate(0, 50);
canvas.drawBitmap(bitmap, 100, 100, paint);

// 缩放，参数分别表示：x轴缩放2倍，y轴缩放2倍，3，4参数表示缩放的起始点
canvas.scale(2, 2, 50+bitmap.getWidth()/2, 50+bitmap.getHeight()/2);
canvas.drawBitmap(bitmap, 100, 100, paint);

// 相对y轴镜像
canvas.scale(1, -1, 50+bitmap.getWidth()/2, 50+bitmap.getHeight()/2);
canvas.drawBitmap(bitmap, 100, 100, paint);
</code></pre>

<p>效果如下：</p>

<p><img src="http://images.cnitblog.com/blog/602984/201402/202006478416495.jpg" alt="image" /></p>

<h4>2、png格式和其他图像格式的区别是，png图像支持背景是透明的，</h4>

<p>可以多个图像叠加在一起，而其他格式的图片就会被旁白覆盖</p>

<pre><code class="java">//绘制一张背景图片，充满整个屏幕
Bitmap bitmap1 = BitmapFactory.decodeResource(this.getResources()
　　　　　　　　　　　　　　　　　　　　, R.drawable.background);
canvas.drawBitmap(bitmap1, 0, 0, paint);

// png的图片，左边螃蟹边缘是透明的，因此不会有问题
Bitmap bitmap2 = BitmapFactory.decodeResource(this.getResources()
　　　　　　　　　　　　　　, R.drawable.crab);
canvas.drawBitmap(bitmap2, 20, 200, paint);

// jpg的图片，右边螃蟹边缘把背景遮挡了
Bitmap bitmap3 = BitmapFactory.decodeResource(this.getResources()
　　　　　　　　　　　　　　, R.drawable.carb2);
canvas.drawBitmap(bitmap3, 200, 230, paint);
</code></pre>

<p>效果图如下：</p>

<p><img src="http://images.cnitblog.com/blog/602984/201402/202009215387750.jpg" alt="image" /></p>

<p>左边的螃蟹图片是png格式的，右边则是jpg格式的，明显右边螃蟹还留有矩形的空白。</p>

<p>3、Bitmap通过均匀改变draw的横纵坐标或者切换图片就会呈现动画的效果,</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/161125238409409.png" alt="image" /></p>

<p>上图是一张波浪的图片</p>

<p>canvas.drawBitmap(bmp, x, y, new Paint());</p>

<p>新建个线程：x+=1，就可以看到海水在动。</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/161127479021832.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161127569961254.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161128073712718.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161128152938597.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161128248241719.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161128354964625.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161128440747904.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161128538556482.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161129022463520.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/161129090278613.png" alt="image" /></p>

<p>上面则是9张卡通鱼的图片，分别命名fish0~fish9，通过来回不断切换图片，就会看到鱼儿在游动</p>

<p>运行效果（由于博主不会录制gif图片，囧！就截2张图，读者自己脑补吧）：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/161133207937998.png" alt="image" /> <img src="http://images.cnitblog.com/i/602984/201403/161215537618984.png" alt="image" /></p>

<p>SurfaceView主要代码：</p>

<pre><code class="java">public MySurfaceView(Context context) {
        super(context);
        // TODO Auto-generated constructor stub
        sfh = this.getHolder();
        sfh.addCallback(this);
        paint = new Paint();
        paint.setColor(Color.WHITE);
        paint.setAntiAlias(true);
        setFocusable(true);
        for (int i = 0; i &lt; fishBmp.length; i++) {
            fishBmp[i] = BitmapFactory.decodeResource(this.getResources(), R.drawable.fish0 + i);
        }
    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width,
            int height) {
        // TODO Auto-generated method stub

    }

    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        // TODO Auto-generated method stub
        bmp = BitmapFactory.decodeResource(this.getResources(), R.drawable.water);
        x = -bmp.getWidth() + this.getWidth();
        //Log.v("chendd", "bmp:"+bmp.getWidth() );
        //Log.v("chendd", "this:"+this.getWidth() );
        y = this.getHeight() - bmp.getHeight();
        flag = true;
        //实例线程
        th = new Thread(this);
        //启动线程
        th.start();
        //Mydraw();
    }

    private void Mydraw() {
        // TODO Auto-generated method stub
        try {
            canvas = sfh.lockCanvas();
            if (canvas != null) {
                canvas.drawColor(Color.WHITE);
                canvas.drawBitmap(bmp, x, y, new Paint());
                canvas.drawBitmap(fishBmp[currentFrame], this.getWidth()/2, this.getHeight()-60, paint);
            }
        } catch (Exception e) {
            // TODO: handle exception
        } finally {
            if (canvas != null)
                sfh.unlockCanvasAndPost(canvas);
        }
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
        // TODO Auto-generated method stub

    }


    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // TODO Auto-generated method stub
        Mydraw();
        return true;
    }

    @Override
    public void run() {
        // TODO Auto-generated method stub
        while (flag) {
            long start = System.currentTimeMillis();
            Mydraw();
            logic();
            long end = System.currentTimeMillis();
            try {
                if (end - start &lt; 10) {
                    Thread.sleep(10 - (end - start));
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void logic() {
        // TODO Auto-generated method stub
        //Log.v("chendd", "x:"+x );
        if(x == (-bmp.getWidth()/2 + this.getWidth())){
            x = -bmp.getWidth() + this.getWidth();
        }else {
            x+=1;
        }
        currentFrame++;
        if (currentFrame &gt;= fishBmp.length) {
            currentFrame = 0;
        }

    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android学习日记8--Paint画笔]]></title>
    <link href="http://chendd.github.io/blog/2014/02/24/android_study_08/"/>
    <updated>2014-02-24T22:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2014/02/24/android_study_08</id>
    <content type="html"><![CDATA[<h2>Paint</h2>

<p>&#160; &#160; &#160; &#160;要绘图，首先得调整画笔，待画笔调整好之后，再将图像绘制到画布Canvas上，
这样才可以显示在手机屏幕上。Android 中的画笔是 Paint类，Paint 中包含了很多方法对其属性进行设置，</p>

<p>Paint方法一般可分两类，图形的绘制和文本的绘制
主要方法如下：（没有全部列出，大家可以查看<a href="http://android.toolib.net/reference/android/graphics/Paint.html">官方文档</a> ）</p>

<!--more-->


<pre><code class="java">canvas.drawColor(Color.GREEN);

Paint paint1 = new Paint();
canvas.drawCircle(40, 30, 20, paint1);

//设置画笔无锯齿，默认有锯齿
paint1.setAntiAlias(true);
canvas.drawCircle(100, 30, 20, paint1);

//设置画笔的透明度
canvas.drawText("无透明度", 100, 70, new Paint());
Paint paint2 = new Paint();
paint2.setAlpha(0x77);
canvas.drawText("半透明度", 20, 70, paint2);

//设置绘制文本的锚点
canvas.drawText("锚点", 20, 90, new Paint());
Paint paint3 = new Paint();

//设置以文本的中心点绘制
paint3.setTextAlign(Paint.Align.CENTER);
canvas.drawText("锚点", 20, 105, paint3);

//获取文本的长度
Paint paint4 = new Paint();
float len =paint4.measureText("文本宽度:");
canvas.drawText("文本长度:"+len, 20, 130, new Paint());

//设置画笔样式
canvas.drawRect(new Rect(20,140,40,160), new Paint());
Paint paint5 = new Paint();

//设置画笔不填充
paint5.setStyle(Style.STROKE);
canvas.drawRect(new Rect(60,140,80,160), paint5);

//设置画笔颜色
Paint paint6 = new Paint();
paint6.setColor(Color.GRAY);
canvas.drawText("灰色", 30, 180, paint6);

//设置画笔的粗细程度
canvas.drawLine(20, 200,70, 200, new Paint());
Paint paint7 = new Paint();
paint7.setStrokeWidth(7);
canvas.drawLine(20, 220,70, 220,paint7);

//设置画笔绘制文本的字体粗细
Paint paint8 = new Paint();
paint8.setTextSize(20);
canvas.drawText("文字尺寸", 20, 260, paint8);

//设置画笔的ARGB分量 ，a值 (透明度)
Paint paint9 = new Paint();
paint9.setARGB(0x77, 0xff, 0x00, 0x00);
canvas.drawText("红色半透明", 20, 290, paint9);
</code></pre>

<p><img src="http://images.cnitblog.com/blog/602984/201402/182002322713875.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android学习日记7--Canvas画布]]></title>
    <link href="http://chendd.github.io/blog/2014/02/22/android_study_07/"/>
    <updated>2014-02-22T22:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2014/02/22/android_study_07</id>
    <content type="html"><![CDATA[<h4>1、Canvas</h4>

<p>&#160; &#160; &#160; &#160;Canvas类主要实现了屏幕的绘制过程，其中包含了很多实用的方法，比如绘制一条路径、区域、贴图、画点、画线、渲染文本，
当然Android官网提示大家很多方法有不同的重载版本，参数更灵活。</p>

<!--more-->


<p>&#160; &#160; &#160; &#160;2D部分是android SDK内部自己提供，3D部分是用Open GL ES(3D部分先直接pass，除非你要做些3D游戏之类的)。大部分2D使用的api都在android.graphics和android.graphics.drawable包中。</p>

<p><a href="http://android.toolib.net/reference/android/graphics/Canvas.html">API参考地址</a></p>

<p>&#160; &#160; &#160; &#160;下面是Canvas类常用的简单方法</p>

<pre><code class="java">// 设置画布颜色为蓝色
canvas.drawColor(Color.BLUE);

//canvas.drawPoint(x, y, paint); x、y表示绘制点的坐标
//canvas.drawPoints(pts, paint);pts表示绘制点存储的数组，两两值表示一个坐标点
//canvas.drawPoints(pts, offset, count, paint);offset表示跳过哪些点,count表示实际绘制的个数
float[] pts= {10,10,120,120,230,230,40,40,90,90};
canvas.drawPoints(pts, paint);
</code></pre>

<p>绘制散点图：</p>

<p><img src="http://images.cnitblog.com/blog/602984/201402/181939296215102.png" alt="image" /></p>

<pre><code class="java">canvas.drawPoints(pts,3,4, paint);
</code></pre>

<p>跳过pts前3值后开始算4个值的数据(120,230,230,40)</p>

<p>即绘制（120，230）、(230,40)两个点</p>

<p><img src="http://images.cnitblog.com/blog/602984/201402/181940540028379.png" alt="image" /></p>

<p>绘制几何图形：</p>

<p><img src="http://images.cnitblog.com/i/602984/201404/261129023103474.png" alt="image" /></p>

<pre><code class="java">public GeometryView(Context context) {
super(context);
mPaint = new Paint();
// 设置抗锯齿
mPaint.setFlags(Paint.ANTI_ALIAS_FLAG);
}

@Override
protected void onDraw(Canvas canvas) {
super.onDraw(canvas);

//设置画布颜色 也就是背景颜色
canvas.drawColor(Color.WHITE);

mPaint.setColor(Color.BLACK);
canvas.drawText("绘制无规则几何图形", 150, 30, mPaint);

//绘制一条线
mPaint.setColor(Color.BLACK);
mPaint.setStrokeWidth(4);
canvas.drawLine(0, 0, 100, 100, mPaint);

//绘制一个矩形
mPaint.setColor(Color.YELLOW);
canvas.drawRect(0, 120, 100, 200, mPaint);

//绘制一个圆形
mPaint.setColor(Color.BLUE);
canvas.drawCircle(80, 300, 50, mPaint);

//绘制一个椭圆
mPaint.setColor(Color.CYAN);
canvas.drawOval(new RectF(300,370,120,100), mPaint);

//绘制多边形
mPaint.setColor(Color.BLACK);
Path path = new Path();
path.moveTo(150+5 , 400 -50);
path.lineTo(150+45, 400 - 50);
path.lineTo(150+30, 460 - 50);
path.lineTo(150+20, 460 - 50);
path.close();
canvas.drawPath(path, mPaint);

}
</code></pre>

<p>&#160; &#160; &#160; &#160;此外还有好多绘制各种简单图形的方法，偷懒就不一一写了，需要的时候可以去查api文档，</p>

<p>或者在eclipse 敲canvas.draw 按 ALT+/ 提示</p>

<p><img src="http://images.cnitblog.com/blog/602984/201402/181944254378008.png" alt="image" /></p>

<p>&#160; &#160; &#160; &#160;总的来说，Canvas可以绘制的对象有：弧线(arcs)、填充颜色(argb和color)、Bitmap、圆(circle和oval)、点(point)、线(line)、矩形(Rect)、图片(Picture)、圆角矩形(RoundRect)、文本(text)、顶点(Vertices)、路径(path)。通过组合这些对象我们可以画出一些简单有趣的界面出来，但是光有这些功能还是不够的，如果我要画一个仪表盘(数字围绕显示在一个圆圈中)就比较困难(不要告诉我直接贴一张仪表盘的图片上去，如果要让仪表盘指针会动呢？就没辙了吧！)。</p>

<p>&#160; &#160; &#160; &#160;幸好Android还提供了一些对Canvas位置转换的方法：rorate、scale、translate、skew(扭曲)等，而且它允许你通过获得它的转换矩阵对象(getMatrix方法)直接操作它。这些操作就像是虽然你的笔还是原来的地方画，但是画纸旋转或者移动了，所以你画的东西的方位就产生变化。为了方便一些转换操作，Canvas还提供了保存和回滚属性的方法(save和restore类似数据库commit和rollback)，比如你可以先保存目前画纸的位置(save)，然后旋转90度，向下移动100像素后画一些图形，画完后调用restore方法返回到刚才保存的位置，这些内容将在BitMap的操作中讲到。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android学习日记6--SurfaceView视图]]></title>
    <link href="http://chendd.github.io/blog/2014/02/20/android_study_06/"/>
    <updated>2014-02-20T22:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2014/02/20/android_study_06</id>
    <content type="html"><![CDATA[<h2>一、API关SurfaceView的介绍</h2>

<p>&#160; &#160; &#160; &#160;SurfaceView是视图(View)的继承类，这个视图里内嵌了一个专门用于绘制的Surface。你可以控制这个Surface的格式和尺寸。Surfaceview控制这个Surface的绘制位置。</p>

<!--more-->


<p>&#160; &#160; &#160; &#160;Surface是纵深排序的，这表明它总在自己所在窗口的后面。surfaceview提供了一个可见区域，只有在这个可见区域内 的surface部分内容才可见，可见区域外的部分不可见。surface的排版显示受到视图层级关系的影响，它的兄弟视图结点会在顶端显示。这意味者 surface的内容会被它的兄弟视图遮挡，这一特性可以用来放置遮盖物(overlays)(例如，文本和按钮等控件)。注意，如果surface上面 有透明控件，那么它的每次变化都会引起框架重新计算它和顶层控件的透明效果，这会影响性能。</p>

<p>&#160; &#160; &#160; &#160;你可以通过SurfaceHolder接口访问这个surface，getHolder()方法可以得到这个接口。surfaceview变得可见时，surface被创建；surfaceview隐藏前，surface被销毁。这样能节省资源。如果你要查看 surface被创建和销毁的时机，可以重载surfaceCreated(SurfaceHolder)和 surfaceDestroyed(SurfaceHolder)。</p>

<p>&#160; &#160; &#160; &#160;Surfaceview的核心在于提供了两个线程：UI线程和渲染线程。这里应注意：</p>

<ul>
<li>所有SurfaceView和SurfaceHolder.Callback的方法都应该在UI线程里调用，一般来说就是应用程序主线程。渲染线程所要访问的各种变量应该作同步处理。</li>
<li>由于surface可能被销毁，它只在SurfaceHolder.Callback.surfaceCreated()和 SurfaceHolder.Callback.surfaceDestroyed()之间有效，所以要确保渲染线程访问的是合法有效的surface。</li>
</ul>


<h2>二、SurfaceView流程</h2>

<p>&#160; &#160; &#160; &#160;继承SurfaceView并实现SurfaceHolder.Callback接口 &mdash;-> SurfaceView.getHolder()获得SurfaceHolder对象 &mdash;->SurfaceHolder.addCallback(callback)添加回调函数&mdash;->SurfaceHolder.lockCanvas()获得Canvas对象并锁定画布&mdash;-> Canvas绘画 &mdash;->SurfaceHolder.unlockCanvasAndPost(Canvas canvas)结束锁定画图，并提交改变，将图形显示</p>

<h2>三、SurfaceView具体实现</h2>

<p>&#160; &#160; &#160; &#160;用SurfaceView实现上篇View视图一样的例子</p>

<p><img src="http://images.cnitblog.com/blog/602984/201402/171953189042933.png" alt="image" /></p>

<p>讲解写在注释里</p>

<pre><code class="java">package com.example.gamesurfaceview2;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceHolder.Callback;
import android.view.SurfaceView;

//SurfaceView 还要继承CallBack接口
public class MySurfaceView extends SurfaceView implements Callback,Runnable{

    private SurfaceHolder sfh;
    private Paint paint;
    private int x,y;
    private Thread thread;
    private boolean flag;
    private Canvas canvas;
    private int w,h;

    public MySurfaceView(Context context) {
        super(context);
        // TODO Auto-generated constructor stub
        //通过SurfaceHolder来和Can打交道
        sfh = this.getHolder();
        //添加监听
        sfh.addCallback(this);
        x =20;
        y =20;
        paint = new Paint();
        paint.setColor(Color.WHITE);
        setFocusable(true);
    }

    @Override
    /**
     * surfaceView发生改变时执行的方法
     */
    public void surfaceChanged(SurfaceHolder holder, int format, int width,
            int height) {
        // TODO Auto-generated method stub

    }

    @Override
    /**
     * surfaceView创建时执行的方法
     */
    public void surfaceCreated(SurfaceHolder holder) {
        // TODO Auto-generated method stub
        h = this.getHeight();
        w = this.getWidth();
        flag = true;
        thread = new Thread(this);
        thread.start();
    }

    /**
     * 自己定义的绘画调用方法
     */
    private void Mydraw() {
        try {
            // 获取一个加锁的画布，防止被其他修改
            canvas = sfh.lockCanvas();
            if (canvas != null) {
                //-----------利用填充矩形的方式，刷屏
                ////绘制矩形
                //canvas.drawRect(0,0,this.getWidth(),
                //this.getHeight(), paint);
                //-----------利用填充画布，刷屏
                //        canvas.drawColor(Color.BLACK);
                //-----------利用填充画布指定的颜色分量，刷屏
                // 没重画图像会叠在一起
                canvas.drawRGB(0, 0, 0);
                canvas.drawText("Game", x, y, paint);
            }
        } catch (Exception e) {
            // TODO: handle exception
        } finally {
            if (canvas != null)
                // 解锁和提交画布
                sfh.unlockCanvasAndPost(canvas);
        }
    }

    @Override
    /**
     * surfaceView被销毁时执行的方法
     */
    public void surfaceDestroyed(SurfaceHolder holder) {
        // TODO Auto-generated method stub

    }


    @Override
    /**
     * 触摸屏幕事件
     */
    public boolean onTouchEvent(MotionEvent event) {
        // TODO Auto-generated method stub
        x= (int) event.getX();
        y= (int) event.getY();
        return true;
    }


    /**
     * 游戏逻辑
     */
    private void logic() {

    }
    @Override
    public void run() {
        while (flag) {
            long start = System.currentTimeMillis();
            Mydraw();
            logic();
            long end = System.currentTimeMillis();
            try {
                // 50毫秒刷新一次
                if (end - start &lt; 50) {
                    Thread.sleep(50 - (end - start));
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


}
</code></pre>

<p>注意：当画布没有重画覆盖时，会出现如下重叠效果：</p>
]]></content>
  </entry>
  
</feed>
