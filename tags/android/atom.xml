<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: android | Chendd's Blog]]></title>
  <link href="http://chendd.github.io/tags/android/atom.xml" rel="self"/>
  <link href="http://chendd.github.io/"/>
  <updated>2016-08-23T16:30:25+08:00</updated>
  <id>http://chendd.github.io/</id>
  <author>
    <name><![CDATA[chendd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Hook框架Xposed入门]]></title>
    <link href="http://chendd.github.io/blog/2016/05/15/learn_xposed/"/>
    <updated>2016-05-15T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2016/05/15/learn_xposed</id>
    <content type="html"><![CDATA[<h2>一.基础知识</h2>

<p>&#160; &#160; &#160; &#160;Xposed是Android平台上较为出名的一个开源框架。在这个框架下，我们可以加载很多插件App，这些插件App可以直接或间接操纵普通应用甚至系统上的东西。Xposed原理上是Hook Android 系统的核心进程Zygote来达到修改程序运行过程和结果。讲到这里，可能有人会问什么是Hook？什么是Zygote？</p>

<!--more-->


<ul>
<li><p>Hook(钩子)，钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。</p></li>
<li><p>Zygote(Android进程名)，Android系统是基于Linux内核的，而在Linux系统中，所有的进程都是init进程的子孙进程，也就是说，所有的进程都是直接或者间接地由init进程fork出来的。在Android系统中，所有的应用程序进程以及系统服务进程SystemServer都是由Zygote进程孕育（fork）出来的，这也许就是为什么要取名英文本意为受精卵的Zygote原因吧。</p></li>
</ul>


<p>&#160; &#160; &#160; &#160;由于Xposed框架Hook了Android的核心进程Zygote，而其他应用启动都是从Zygote进程fork而来，就够达到针对系统上所有的应用程序进程的Hook。</p>

<h2>二.Xposed简介</h2>

<ul>
<li><p>官网地址： <a href="http://repo.xposed.info/">http://repo.xposed.info/</a></p></li>
<li><p>源码地址： <a href="https://github.com/rovo89">https://github.com/rovo89</a></p></li>
</ul>


<p>&#160; &#160; &#160; &#160;rovo89大神github主页,如图所示</p>

<p>&#160; &#160; &#160; &#160;<img src="http://7arnbf.com1.z0.glb.clouddn.com/01.png" alt="image" /></p>

<p>主页大致可以看出，xposed主要由三个项目来组成的</p>

<ul>
<li>Xposed，Xposed框架的native部分（主要是修改app_process二进制文件）</li>
<li>XposedBridge,Xposed向开发者提供的API与相应的工具类库</li>
<li>XposedInstaller,Xposed框架的Android端本地管理，环境架构搭建，以及第三方module资源下载的工具。</li>
</ul>


<p>xposed目前已逐步支持ART虚拟机，兼容android 5.0以上版本</p>

<h2>三.Xposed使用</h2>

<p>&#160; &#160; &#160; &#160;在Android 4.0以上Android设备（需root权限，建议直接用模拟器）安装<a href="http://repo.xposed.info/module/de.robv.android.xposed.installer">XposedInstaller</a></p>

<p>启动XposedInstaller点击 【框架】</p>

<p><img src="http://7arnbf.com1.z0.glb.clouddn.com/02.png" alt="image" /></p>

<p>点击 【安装/更新】 并重启，再点击框架看到看到 激活底下两个都是绿色 代表框架安装成功</p>

<p><img src="http://7arnbf.com1.z0.glb.clouddn.com/03.png" alt="image" /></p>

<p>我们可以点击【下载】来查看热门插件进行安装</p>

<p>安装完插件点击【模块】进行勾选激活</p>

<p>之后还需重启，插件才能生效。大家可以自己下载几个插件玩玩，本文重点不在这，就不演示了。</p>

<h2>四.编写插件</h2>

<p>这里我们hook自己编写的一个小的登录app来获取用户名密码。</p>

<p>界面比较简单，输入用户名密码点击登录弹出用户输入的密码</p>

<p><img src="http://7arnbf.com1.z0.glb.clouddn.com/05.png" alt="image" /></p>

<p>界面代码</p>

<pre><code class="java">public EditText et_username;
    // 属性为private 时普通反射获取不到该对象
    // private  EditText et_password;
    public EditText et_password;

    public Button bt_login;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        et_username = (EditText) findViewById(R.id.et_username);
        et_password = (EditText) findViewById(R.id.et_password);

        bt_login = (Button) findViewById(R.id.bt_login);
        bt_login.setOnClickListener(this);
    }


    private boolean isCorrectInfo(String username, String password) {
        // 校验用户名密码是否正确，直接返回true
        return true;
    }


    @Override
    public void onClick(View v) {
        switch (v.getId()) {
        case R.id.bt_login:
            if(isCorrectInfo(et_username.getText().toString(), et_password.getText().toString())) {
                // 帐号密码校验成功，弹出当前密码
                Toast.makeText(MainActivity.this, "password:"+et_password.getText().toString(), Toast.LENGTH_SHORT).show();
            }
            break;

        default:
            break;
        }
    }
</code></pre>

<h4>1.在AndroidManifest.xml文件中配置插件名称与Api版本号</h4>

<pre><code class="xml">&lt;application
    android:allowBackup="true"
    android:icon="@drawable/ic_launcher"
    android:label="@string/app_name"
    android:theme="@style/AppTheme" &gt;

    &lt;!-- 标记xposed插件 --&gt;   
    &lt;meta-data
        android:name="xposedmodule"
        android:value="true" /&gt;
    &lt;!-- 模块描述 --&gt;
    &lt;meta-data
        android:name="xposeddescription"
        android:value="登录hook例子！" /&gt;
    &lt;!-- 最低版本号 --&gt;
    &lt;meta-data
        android:name="xposedminversion"
        android:value="54" /&gt;

&lt;/application&gt;
</code></pre>

<h4>2.下载其API库<a href="http://forum.xda-developers.com/xposed/xposed-api-changelog-developer-news-t2714067">XposedBridgeApi-.jar</a></h4>

<p>&#160; &#160; &#160; &#160;下载完毕后我们需要将Xposed Library复制到lib目录（注意是lib目录，不是Android提供的libs目录），然后将这个jar包添加到Build PATH中。</p>

<h4>3.声明主入口路径</h4>

<p>需要在assets文件夹中新建一个xposed_init的文件，并在其中声明主入口类。如这里我们的主入口类为
<code>java
com.example.xposedtest.HookUtil
</code></p>

<p><img src="http://7arnbf.com1.z0.glb.clouddn.com/04.png" alt="image" /></p>

<h4>4.使用findAndHookMethod方法Hook劫持登陆信息</h4>

<p>&#160; &#160; &#160; &#160;这是最重要的一步，我们之前所分析的都需要到这一步进行操作。如我们之前所分析的登陆程序，我们需要劫持，就是需要Hook其com.example.logintest.MainActivity中的isCorrectInfo方法。我们使用Xposed提供的findAndHookMethod直接进行MethodHook操作。在其Hook回调中使用XposedBridge.log方法，将登陆的账号密码信息打印至Xposed的日志中。具体操作如下所示</p>

<pre><code class="java">public class HookUtil implements IXposedHookLoadPackage{

    @Override
    public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable {
        // 标记目标app包名
        if (!lpparam.packageName.equals("com.example.logintest"))
            return;
        XposedBridge.log("Loaded app: " + lpparam.packageName);

        // Hook MainActivity中的isCorrectInfo(String,String)方法
        // findAndHookMethod(hook方法的类名，classLoader，hook方法名，hook方法参数...，XC_MethodHook)
        XposedHelpers.findAndHookMethod("com.example.logintest.MainActivity", lpparam.classLoader, "isCorrectInfo", String.class,
                String.class, new XC_MethodHook() {

                    @Override
                    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                        XposedBridge.log("开始hook");
                        XposedBridge.log("参数1 = " + param.args[0]);
                        XposedBridge.log("参数2 = " + param.args[1]);
                    }

                    @Override
                    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                        XposedBridge.log("结束hook");
                        XposedBridge.log("参数1 = " + param.args[0]);
                        XposedBridge.log("参数2 = " + param.args[1]);

                    }
                });


    }

}
</code></pre>

<h4>5.运行程序，查看效果</h4>

<p><img src="http://7arnbf.com1.z0.glb.clouddn.com/06.png" alt="image" /></p>

<p>&#160; &#160; &#160; &#160;重启Android设备，进入XposedInstaller点击【日志】查看，因为我们之前使用的是XposedBridge.log方法打印log，所以log都会显示在此处。我们发现我们需要劫持的账号密码都显示再来此处。</p>

<p><img src="http://7arnbf.com1.z0.glb.clouddn.com/07.png" alt="image" /></p>

<p>&#160; &#160; &#160; &#160;这里由于demo是我们自己写的，所以知道hook它的帐号校验方法isCorrectInfo来获取用户名密码，如果有些程序账户校验没有封装方法呢？其实我们可以hook其它一些必有的方法，如button的onClick方法，甚至可以动态改变EditText的内容，做法如下:</p>

<pre><code class="java">
public class HookUtil implements IXposedHookLoadPackage{

    @Override
    public void handleLoadPackage(LoadPackageParam lpparam) throws Throwable {
        // 标记目标app包名
        if (!lpparam.packageName.equals("com.example.logintest"))
            return;
        XposedBridge.log("Loaded app: " + lpparam.packageName);


        // Hook MainActivity中的onClick(View v)方法
        XposedHelpers.findAndHookMethod("com.example.logintest.MainActivity", lpparam.classLoader, "onClick", View.class, new XC_MethodHook() {

                    @Override
                    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    }

                    @Override
                    protected void afterHookedMethod(MethodHookParam param) throws Throwable {

                        Class clazz = param.thisObject.getClass();
                        XposedBridge.log("class name:"+clazz.getName());

                        Field field = clazz.getField("et_password");// 密码输入框 id

                        EditText password = (EditText) field.get(param.thisObject);

                        String string = password.getText().toString();
                        XposedBridge.log("密码 = " + string);
                        // 设置新密码
                        password.setText("改你妹啊!!");

                    }
                });




    }

}
</code></pre>

<p><img src="http://7arnbf.com1.z0.glb.clouddn.com/08.png" alt="image" /></p>

<p>&#160; &#160; &#160; &#160;点击登录按钮，发现输入框内容改变了</p>

<p><img src="http://7arnbf.com1.z0.glb.clouddn.com/09.png" alt="image" /></p>

<p>&#160; &#160; &#160; &#160;之前登录app密码EditText声明为 private 时，导致反射获取报NoSuchFileException，原因是普通的反射不能获取私有变量，
改为EditText声明改为public后成功，或者不能改EditText声明时，可以用以下方法，无论公有私有都可以获取</p>

<pre><code class="java">
// 输入框不为私有private 可通过以下方式获取 
// Field field = clazz.getField("et_password");// 密码输入框 id

// 通过类的字节码得到该类中声明的所有属性，无论私有或公有
Field field = clazz.getDeclaredField("et_password");
// 设置访问权限（这点对于有过android开发经验的可以说很熟悉）
field.setAccessible(true);
</code></pre>

<h2>4.总结</h2>

<p>&#160; &#160; &#160; &#160;既然能成功Hook自己的App，那么系统应用和其它应用的也同理，只不过需要知道系统公开接口或者反编译获得相应的接口，下次讲解Hook微信做些好玩的东西。</p>

<p>附：</p>

<p>我的demo: <a href="https://github.com/chendd/XposedTest.git">https://github.com/chendd/XposedTest.git</a></p>

<p>官方教程: <a href="https://github.com/rovo89/XposedBridge/wiki/Development-tutorial">https://github.com/rovo89/XposedBridge/wiki/Development-tutorial</a></p>

<p>官方例子: <a href="https://github.com/rovo89/XposedExamples">https://github.com/rovo89/XposedExamples</a></p>

<p>参考文章: <a href="http://www.csdn.net/article/1970-01-01/2825462">http://www.csdn.net/article/1970-01-01/2825462</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编写高效的Android代码]]></title>
    <link href="http://chendd.github.io/blog/2013/05/15/efficient_android_code/"/>
    <updated>2013-05-15T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/05/15/efficient_android_code</id>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;编写Android程序时要时刻考虑执行的效率，这系统不是想象中的那么快，并且你还要考虑它电池的续航能力。写程序的时候，要尽可能的使你的代码优化而提高效率。</p>

<p>&#160; &#160; &#160; &#160;对于如何判断一个系统的不合理，这里有两个基本的原则：</p>

<h4>1、不要做不必要做的事情。</h4>

<h4>2、尽可能的节省内存的使用。</h4>

<!--more-->


<p>&#160; &#160; &#160; &#160;下面是常用的几点优化建议：</p>

<h4>1、尽可能避免创建对象（Object）</h4>

<p>&#160; &#160; &#160; &#160;因为对象的创建并不是没有代价的，如果你在一个用户界面的循环中分配一个对象，你不得不强制的进行内存回收，那么就会使用户体验出现稍微“打嗝”的现象。</p>

<p>&#160; &#160; &#160; &#160;当从原始的输入数据中提取字符串时，试着从原始字符串返回一个子字符串，而不是创建一份拷贝。</p>

<h4>2、使用自身方法（Use Native Methods）</h4>

<p>&#160; &#160; &#160; &#160;当处理字符串的时候，不要犹豫，尽可能多的使用诸如String.indexOf()、String.lastIndexOf()这样对象自身带有的方法。因为这些方法使用C/C++来实现的，
要比在一个java循环中做同样的事情快10-100倍。</p>

<h4>3、缓冲属性调用Cache Field Lookups</h4>

<p>&#160; &#160; &#160; &#160;访问对象属性要比访问本地变量慢得多。你不应该这样写你的代码：</p>

<pre><code class="java">for (int i = 0; i &lt; this.mCount; i++)
      dumpItem(this.mItems[i]);
</code></pre>

<p>&#160; &#160; &#160; &#160;而是应该这样写：</p>

<pre><code class="java">  int count = this.mCount;
  Item[] items = this.mItems;

  for (int i = 0; i &lt; count; i++)
      dumpItems(items[i]);
</code></pre>

<p>&#160; &#160; &#160; &#160;我们直接使用“this”表明这些是它的成员变量</p>

<h4>4、声明Final常量</h4>

<p>&#160; &#160; &#160; &#160;我们可以看看下面一个类顶部的声明：</p>

<pre><code class="java">static int intVal = 42;
static String strVal = "Hello, world!";
</code></pre>

<p>&#160; &#160; &#160; &#160;当一个类第一次使用时，编译器会调用一个类初始化方法，这个方法将42存入变量intVal，并且为strVal在类文件字符串常量表中提取一个引用，当这些值在后面引用时，就会直接属性调用。</p>

<p>&#160; &#160; &#160; &#160;我们可以用关键字“final”来改进代码：</p>

<pre><code class="java">static final int intVal = 42;
static final String strVal = "Hello, world!";
</code></pre>

<p>&#160; &#160; &#160; &#160;这个类将不会调用类初始化方法，因为这些常量直接写入了类文件静态属性初始化中，这个初始化直接由虚拟机来处理。代码访问intVal将会使用Integer类型的42，访问strVal将使用相对节省的“字符串常量”来替代一个属性调用。
将一个类或者方法声明为“final”并不会带来任何的执行上的好处，它能够进行一定的最优化处理。例如，如果编译器知道一个Get方法不能被子类重载，那么它就把该函数设置成Inline。</p>

<h4>5、避免浮点类型的使用</h4>

<p>&#160; &#160; &#160; &#160;嵌入式的处理器通常并不支持浮点数的处理，因此所有的“float”和“double”操作都是通过软件进行的，一些基本的浮点数的操作就需要花费毫秒级的时间。同时，即使是整数，一些芯片也只有乘法而没有除法。在这些情况下，整数的除法和取模操作都是通过软件实现。</p>

<h4>6、避免列举类型Avoid Enums</h4>

<p>&#160; &#160; &#160; &#160;列举类型非常好用，当考虑到尺寸和速度的时候，就会显得代价很高，例如：</p>

<pre><code class="java">public class Foo {
   public enum Shrubbery { GROUND, CRAWLING, HANGING }
}
</code></pre>

<p>&#160; &#160; &#160; &#160;这会转变成为一个900字节的class文件（Foo$Shrubbery.class）。第一次使用时，类的初始化要在独享上面调用方法去描述列举的每一项，每一个对象都要有它自身的静态空间，整个被储存在一个数组里面（一个叫做“$VALUE”的静态数组）。那是一大堆的代码和数据，仅仅是为了三个整数值。Shrubbery shrub = Shrubbery.GROUND;这会引起一个静态属性的调用，如果GROUND是一个静态的Final变量，编译器会把它当做一个常数嵌套在代码里面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android学习日记25--ANR和Hander消息机制]]></title>
    <link href="http://chendd.github.io/blog/2013/03/30/android_study_25/"/>
    <updated>2013-03-30T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/03/30/android_study_25</id>
    <content type="html"><![CDATA[<h4>1、ANR(Application Not Responding)定义</h4>

<p>　　在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，
这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，
也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现anr，而让用户每次都要处理这个对话框。
因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。默认情况下，在android中Activity的最长执行时间是5秒，
BroadcastReceiver的最长执行时间则是10秒。</p>

<!--more-->


<p><img src="http://images.cnitblog.com/i/602984/201404/172223300108690.jpg" alt="image" /></p>

<h4>2、如何避免ANR</h4>

<p>&#160; &#160; &#160; &#160;Android应用程序通常是运行在一个单独的UI主线程里，因此，运行在主线程里的任何方法都尽可能少做事情。
特别是，Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。
潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里
（或者以数据库操作为例，通过异步请求的方式）来完成。然而，不是说你的主线程阻塞在那里等待子线程的完成——也不是调用
Thread.wait()或是Thread.sleep()。替代的方法是，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。</p>

<h4>3、Hander 定义</h4>

<p>&#160; &#160; &#160; &#160;主要接受子线程发送的数据, 并用此数据配合主线程更新UI.
直接在UI线程中开启子线程来更新TextView显示的内容，运行程序我们会发现，如下错误：</p>

<pre><code>android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
</code></pre>

<p>&#160; &#160; &#160; &#160;翻译过来就是：只有创建这个控件的线程才能去更新该控件的内容。
所有的UI线程要去负责View的创建并且维护它，例如更新冒个TextView的显示，都必须在主线程中去做，我们不能直接在UI线程中去创建子线程，
要利用消息机制：handler，如下就是handler的简单工作原理图:</p>

<p><img src="http://images.cnitblog.com/i/602984/201404/181859021979455.gif" alt="image" /></p>

<p>&#160; &#160; &#160; &#160;Android系统中的Looper负责管理线程的消息队列和消息循环。创建的工作线程默认是没有消息队列和消息循环的，如果想让工作线程具有消息队列和消息循环，</p>

<p>&#160; &#160; &#160; &#160;就需要在线程中先调用Looper.prepare()来创建消息队列，然后调用Looper.loop()进入消息循环。下面是我们创建的工作线程：</p>

<pre><code class="java">class WorkThread extends Thread {
          public Handler mHandler;

          public void run() {
              Looper.prepare();

              mHandler = new Handler() {
                  public void handleMessage(Message msg) {
                      // 处理收到的消息
                  }
              };

              Looper.loop();
          }
      }
</code></pre>

<p>&#160; &#160; &#160; &#160;这样一来，我们创建的工作线程就具有了消息处理机制了。运行在主线程中，Android系统会在Activity启动时为其创建一个消息队列和消息循环，就不需要</p>

<p>Looper.prepare()和Looper.loop();</p>

<h4>4、Hander 用法</h4>

<p>&#160; &#160; &#160; &#160;继承或实现Hendler类，并重写handleMessage(Message msg) 方法, 用于接受线程数据
如下实例：</p>

<p>&#160; &#160; &#160; &#160;启动后，更新后的值一直在增加</p>

<p><img src="http://images.cnitblog.com/i/602984/201404/172206262912209.png" alt="image" /></p>

<p>主要代码：</p>

<pre><code class="java">public class MainActivity extends Activity {

    private TextView tv;
    private static final int UPDATE = 0;
    private Handler handler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            // TODO 接收消息并且去更新UI线程上的控件内容
            if (msg.what == UPDATE) {
                // Bundle b = msg.getData();
                // tv.setText(b.getString("num"));
                tv.setText(String.valueOf(msg.obj));
            }
            super.handleMessage(msg);
        }
    };

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        tv = (TextView) findViewById(R.id.tv);

        new Thread() {
            @Override
            public void run() {
                // TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值
                try {
                    for (int i = 0; i &lt; 100; i++) {
                        Thread.sleep(500);
                        Message msg = new Message();
                        msg.what = UPDATE;
                        // Bundle b = new Bundle();
                        // b.putString("num", "更新后的值：" + i);
                        // msg.setData(b);
                        msg.obj = "更新后的值：" + i;
                        handler.sendMessage(msg);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();
    }

}
</code></pre>

<p>&#160; &#160; &#160; &#160;关于message，指对于Android中Handler可以传递一些内容，通过Bundle对象可以封装String、Integer以及Blob二进制对象，
我们通过在线程中使用Handler对象的sendEmptyMessage或sendMessage方法来传递一个Bundle对象到Handler处理器。
对于Handler类提供了重写方法handleMessage(Message msg) 来判断，通过msg.what来区分每条信息。
将Bundle解包来实现Handler类更新UI线程中的内容实现控件的刷新操作。相关的Handler对象有关消息发送sendXXXX相关方法如下，
同时还有postXXXX相关方法，这些和Win32中的道理基本一致，一个为发送后直接返回，一个为处理后才返回。</p>

<p>&#160; &#160; &#160; &#160;比如我们可以在message里封装Bundle对象。</p>

<p>&#160; &#160; &#160; &#160;两边传递的代码如下：</p>

<pre><code class="java">// 其他Thread里发送
Message msg = new Message();
Bundle b = new Bundle();// 存放数据
b.putString("color", "我的");
msg.setData(b);

// handleMessage里接收
Bundle b = msg.getData();
String color = b.getString("color");
</code></pre>

<h4>5、单线程的消息机制</h4>

<p>&#160; &#160; &#160; &#160;Hander属于多线程的消息机制，Android 单线程事件处理机制 有两种</p>

<ul>
<li>1、基于监听器的机制</li>
</ul>


<p>　　绑定特定的事件监听器，如Button的OnClickListener监听器， 监听器模型:包含事件源(EventSource)、事件(Event)、事件监听器(EventListener)。 一般内部类作为事件监听器类，主要因为 内部类可以在当前类复用;内部类可以调用外部类的组件。当然如果多个 GUI公用一个监听器类，还是使用外部类好一点，只需传入当前的context。当然大部分时间处理没什么复用价值， 更多的时候使用内部匿名类来实现。</p>

<ul>
<li>2、基于回调函数的机制</li>
</ul>


<p>　　重写回调方法，如View的OnKeyDown方法，基于回调函数的机制的事件源和事件监听器是统一的， Android为所有GUI提供一套事件处理方法，当重写回调函数处理完后必需返回true，事件才不会继续向上层调用。</p>

<p>&#160; &#160; &#160; &#160;优劣：基于回调函数 使得更具通用型、代码更加简洁， 基于回调函数 事件模型分工明确、具有更好的维护性 对于特定事件，无法使用回调函数只能使用监听器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android学习日记24--菜单开发]]></title>
    <link href="http://chendd.github.io/blog/2013/03/30/android_study_24/"/>
    <updated>2013-03-30T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/03/30/android_study_24</id>
    <content type="html"><![CDATA[<p>　　菜单是任何应用程序必不可少的一项。按下Menu键或者长按某个View就会弹出相应菜单，当然前提是应用程序有实现菜单功能。
Android平台下的菜单有：Options Menu(选项菜单)、Submenu(子菜单)、Context Menu(上下文菜单)。
这次的案例用以前的索尼真机测试，就不贴代码和运行截图，主要贴些理论知识。菜单这块比较简单，代码实例看<a href="http://www.cnblogs.com/giuz/archive/2010/10/19/1855235.html">这里</a></p>

<!--more--> 


<h2>一、选项菜单和子菜单</h2>

<p>　　Options Menu和Submenu 是一组的，放在一起介绍，一般用于开发普通的选项菜单。</p>

<p>相关回调方法及说明：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292323410312532.png" alt="image" /></p>

<p>涉及到相关类详解：</p>

<h4>1、Menu类</h4>

<p>　　一个Menu对象代表一个菜单，Menu对象中可以添加菜单项MenuItem，也可以添加子菜单SubMenu。常用方法如下:</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292324064696628.png" alt="image" /></p>

<p>注意：clear() 方法用于清除已添加的菜单，通过代码运行中的clear()再add()可以用于动态配置菜单。</p>

<h4>2、MenuItem类</h4>

<p>　　一个MenuIten对象代表一个菜单项，通常MenuItem实例通过Menu的add方法获得。常用方法如下：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292325371093303.png" alt="image" /></p>

<p>注意：Android最多支持6个MenuItem，多了以后就摆在More里面。</p>

<h4>3、SubMenu类</h4>

<p>　　一个SubMenu对象代表一个子菜单，可以理解为菜单的菜单，即Menu对象点进去弹出来的就叫子菜单，每个SubMenu实例代表一个子菜单，常用的方法如下</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292326297037235.png" alt="image" /></p>

<p>一般用法：</p>

<ul>
<li>1、在主Activity中覆盖onCreateOptionsMenu(Menu menu)方法,子菜单也在这里添加</li>
<li>2、如果要添加点击事件，则要覆盖onOptionsItemSelected(MenuItem item)方法</li>
</ul>


<h2>二、上下文菜单</h2>

<p>　　Context Menu类似于电脑上的右键，长按某个View之后弹出来的菜单。也是继承自Menu，不同于选项菜单，
选项菜单服务于Activity，而上下文是注册到某个VIew对象上的。如果一个View对象注册了上下文菜单，用户可以通过长按两秒该View对象调出上下文菜单。</p>

<p>用法同普通菜单，方法名称由Options替换Context</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292327403289825.png" alt="image" /></p>

<h2>三、用XML配置菜单</h2>

<p>　　注意到新建项目的MainActivity 都会重写onCreateOptionsMenu方法
里面代码：
getMenuInflater().inflate(R.menu.main, menu);
就是通过XML来设置菜单的。</p>

<p>如下在res/menu/main.xml 就是本来的配置菜单</p>

<pre><code class="xml">&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt;

    &lt;item
        android:id="@+id/action_settings"
        android:orderInCategory="100"
        android:showAsAction="never"
        android:title="@string/action_settings"/&gt;

&lt;/menu&gt;
</code></pre>

<p>其他同再JAVA代码里的写法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android学习日记23--XML解析]]></title>
    <link href="http://chendd.github.io/blog/2013/03/29/android_study_23/"/>
    <updated>2013-03-29T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/03/29/android_study_23</id>
    <content type="html"><![CDATA[<h2>一、简述</h2>

<p>　　XML语言是跨平台，JAVA对XML语言支持得比较好，android系统的应用层平台是JAVA做的，所以用XML。
XML解析比较简单。XML解析就是将获取到的数据分离出来，基本的网络数据传输，需要使用XML
比如天气预报，从网上获取的是XML文件，通过XML解析可以把天气状态读出来
例：</p>

<pre><code class="xml">&lt;forecast_date data="2009-07-31" /&gt;
&lt;condition data="晴" /&gt;
&lt;humidity data="湿度： 65%" /&gt;
</code></pre>

<p>可得到 2009-07-31 晴 湿度：65%</p>

<p>还有一作用是保存你的数据，比如做个旅游网站，你需要把全国各个省、城市名称写到XML文件进行保存，在程序中通过解析读取调用。</p>

<!--more-->


<p>Android 平台上可用的XML解析有三种</p>

<ul>
<li>1、Simple API for XML(SAX)</li>
<li>2、Document Object Model(DOM)</li>
<li>3、Android附带的pull解析器</li>
</ul>


<h2>二、实例</h2>

<p>分别用三种方法解析如下persons.xml文件（文件放在assert目录下）</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persons&gt;
    &lt;person id="23"&gt;
        &lt;name&gt;liming&lt;/name&gt;
        &lt;age&gt;30&lt;/age&gt;
    &lt;/person&gt;
    &lt;person id="20"&gt;
        &lt;name&gt;dehua&lt;/name&gt;
        &lt;age&gt;25&lt;/age&gt;
    &lt;/person&gt;
&lt;/persons&gt;
</code></pre>

<p>还需定义个javabean 用于存放解析出来的内容</p>

<pre><code class="java">package com.example.xml;

public class Person {
    private Integer id;
    private String name;
    private Short age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Short getAge() {
        return age;
    }

    public void setAge(Short age) {
        this.age = age;
    }

//    @Override
//    public String toString() {
//        return "id:" + id + ", name:" + name + ", age:" + age;
//    }
}
</code></pre>

<h4>1、Simple API for XML(SAX)</h4>

<p>　　SAX是一个解析速度快并且占用内存少的XML解析器，很适合用于Android等移动设备。
SAX解析XML文件采用的是事件驱动，也就是说，它并不需要解析完整个文档，在按内容顺序解析文档的过程中，
SAX会判断当前读到的字符是否合法XML语法中的某部分，如果符合就会触发事件。所谓事件，其实就是一些回调（callback）方法，
这些方法(事件)定义在ContentHandler接口。</p>

<p>　　直接看代码:</p>

<pre><code class="java">public class XMLContentHandler extends DefaultHandler {
    private List&lt;Person&gt; persons = null;
    private Person currentPerson;
    private String tagName = null;// 当前解析的元素标签    
    private static final String TAG = "XMLContentHandler"; 

    public List&lt;Person&gt; getPersons() {
        return persons;
    }

    /* 
     * 接收文档的开始的通知。
     */

    @Override
    public void startDocument() throws SAXException {
        persons = new ArrayList&lt;Person&gt;();
         Log.i(TAG, "startDocument");  
    }

    /* 
     * 结束文档的开始的通知。
     */

    @Override
    public void endDocument() throws SAXException {
        super.endDocument();
         Log.i(TAG, "endDocument");  
    }

    /* 
     * 接收字符数据的通知。
     */

    @Override
    public void characters(char[] ch, int start, int length)
            throws SAXException {
        if (tagName != null) {
            String data = new String(ch, start, length);
            if (tagName.equals("name")) {
                this.currentPerson.setName(data);
            } else if (tagName.equals("age")) {
                this.currentPerson.setAge(Short.parseShort(data));
            }
        }
        Log.i(TAG, "characters("+ch.toString()+","+start+","+length+")"); 

    }

    /*
     * 
     * 接收元素开始的通知。
     * 参数意义如下： 
     * namespaceURI：元素的命名空间 
     * localName ：元素的本地名称（不带前缀） 
     * qName ：元素的限定名（带前缀）
     * atts ：元素的属性集合
     */

    @Override
    public void startElement(String namespaceURI, String localName,
            String qName, Attributes atts) throws SAXException {

        if (localName.equals("person")) {
            currentPerson = new Person();
            currentPerson.setId(Integer.parseInt(atts.getValue("id")));
        }

        this.tagName = localName;
        Log.i(TAG, "startElement("+namespaceURI+","+localName+","+qName+atts+")"); 

    }

    /* 
     * 接收文档的结尾的通知。
     * 参数意义如下：
     * uri ：元素的命名空间
     * localName ：元素的本地名称（不带前缀）
     * name ：元素的限定名（带前缀）
     */
    @Override
    public void endElement(String uri, String localName, String name)
            throws SAXException {

        if (localName.equals("person")) {
            persons.add(currentPerson);
            currentPerson = null;
        }

        this.tagName = null;
        Log.i(TAG, "endElement("+uri+","+localName+","+name+")"); 

    }
}
</code></pre>

<h4>2、Document Object Model(DOM)</h4>

<p>　　DOM解析XML文件时，会将XML文件的所有内容读取到内存中，然后允许您使用DOM API遍历XML树、检索所需的数据。
使用DOM操作XML的代码看起来比较直观，并且，在某些方面比基于SAX的实现更加简单。但是，因为DOM需要将XML文件的所有内容读取到内存中，
所以内存的消耗比较大，特别对于运行Android的移动设备来说，因为设备的资源比较宝贵，所以建议还是采用SAX来解析XML文件，
当然，如果XML文件的内容比较小采用DOM是可行的。</p>

<pre><code class="java">public class DomParseXML {

    public List&lt;Person&gt; readXML(InputStream inStream) {

        List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();// 获取实例

        try {

            DocumentBuilder builder = factory.newDocumentBuilder();
            Document dom = builder.parse(inStream);
            Element root = dom.getDocumentElement();
            NodeList items = root.getElementsByTagName("person");// 查找所有person节点

            for (int i = 0; i &lt; items.getLength(); i++) {

                Person person = new Person();

                // 得到第一个person节点
                Element personNode = (Element) items.item(i);

                // 获取person节点的id属性值
                person.setId(new Integer(personNode.getAttribute("id")));

                // 获取person节点下的所有子节点(标签之间的空白节点和name/age元素)
                NodeList childsNodes = personNode.getChildNodes();

                for (int j = 0; j &lt; childsNodes.getLength(); j++) {

                    Node node = (Node) childsNodes.item(j); // 判断是否为元素类型
                    if (node.getNodeType() == Node.ELEMENT_NODE) {
                        Element childNode = (Element) node;

                        // 判断是否name元素
                        if ("name".equals(childNode.getNodeName())) {

                            // 获取name元素下Text节点,然后从Text节点获取数据
                            person.setName(childNode.getFirstChild()
                                    .getNodeValue());

                        } else if ("age".equals(childNode.getNodeName())) {
                            person.setAge(new Short(childNode.getFirstChild()
                                    .getNodeValue()));

                        }
                    }
                }
                persons.add(person);
            }
            inStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return persons;

    }
}
</code></pre>

<h4>3、Android附带的pull解析器</h4>

<p>　　Pull解析和Sax解析很相似，都是轻量级的解析，在Android的内核中已经嵌入了Pull，所以我们不需要再添加第三方jar包来支持Pull。
Pull解析和Sax解析不一样的地方有(1)pull读取xml文件后触发相应的事件调用方法返回的是数字(2)pull可以在程序中控制想解析到哪里就可以停止解析。</p>

<pre><code class="java">public class PullParseXML {

    public List&lt;Person&gt; readXML(InputStream inStream) throws XmlPullParserException, IOException{

        List&lt;Person&gt; persons = null;  
        Person person = null;  
        XmlPullParser parser = Xml.newPullParser();  
        parser.setInput(inStream, "UTF-8");  

        int event = parser.getEventType();//产生第一个事件  
        while(event!=XmlPullParser.END_DOCUMENT){  
            switch(event){  
            case XmlPullParser.START_DOCUMENT://判断当前事件是否是文档开始事件  
                persons = new ArrayList&lt;Person&gt;();//初始化Persons集合  
                break;  
            case XmlPullParser.START_TAG://判断当前事件是否是标签元素开始事件  
                if("person".equals(parser.getName())){//判断开始标签元素是否是person  
                    person = new Person();  
                    person.setId(Integer.parseInt(parser.getAttributeValue(0)));//得到Person标签的属性值，并设置Person的id  
                }  
                if(person!=null){  
                    if("name".equals(parser.getName())){//判断开始标签元素是否是name  
                        person.setName(parser.nextText());  
                    }else if("age".equals(parser.getName())){//判断开始标签元素是否是price  
                        person.setAge(Short.parseShort(parser.nextText()));  
                    }  
                }  
                break;  
            case XmlPullParser.END_TAG://判断当前事件是否是标签元素结束事件  
                if("person".equals(parser.getName())){//判断结束标签元素是否是Person  
                    persons.add(person);//将person添加到persons集合  
                    person = null;  
                }  
                break;  
            }  
            event = parser.next();//进入下一个元素并触发相应事件  
        }//end while  
        return persons;  

    }
}
</code></pre>

<p>运行界面：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/291207400008256.png" alt="image" /></p>

<p>绑定按钮触发的事件代码:</p>

<pre><code class="java">@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        textView = (TextView)findViewById(R.id.textView);  
        sax_prase = (Button)findViewById(R.id.sax_prase);  
        dom_parse = (Button)findViewById(R.id.dom_parse);  
        pull_parse = (Button)findViewById(R.id.pull_parse);


        try {
            inStream = getAssets().open("persons.xml");
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        //绑定按钮监听器  
        sax_prase.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                persons = SaxParseXML(inStream); 
                for (Person person : persons) {  
                    Log.i(TAG, person.getId()+":"+person.getName()+":"+person.getAge()); 
                } 
            }  
        });  
        //绑定按钮监听器  
        dom_parse.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  

                DomParseXML domParseXML = new DomParseXML();            
                persons = domParseXML.readXML(inStream);
                for (Person person : persons) {  
                    Log.i(TAG, person.getId()+":"+person.getName()+":"+person.getAge()); 
                } 
            }  
        });  
        pull_parse.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  

                PullParseXML pullParseXML = new PullParseXML();                             
                try {
                    persons = pullParseXML.readXML(inStream);
                } catch (XmlPullParserException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                for (Person person : persons) {  
                    Log.i(TAG, person.getId()+":"+person.getName()+":"+person.getAge()); 
                } 

            }  
        });
    }

    private static List&lt;Person&gt; SaxParseXML(InputStream inStream) {
        // TODO Auto-generated method stub
        try {
            SAXParserFactory spf = SAXParserFactory.newInstance();
            SAXParser saxParser = spf.newSAXParser(); // 创建解析器

            // 设置解析器的相关特性，http://xml.org/sax/features/namespaces = true
            // 表示开启命名空间特性,缺省情况设为true，设置使代码更具可读性,但我加进去报错，索性注释掉
            //saxParser.setProperty("http://xml.org/sax/features/namespaces",true);
            XMLContentHandler handler = new XMLContentHandler();

            saxParser.parse(inStream, handler);
            inStream.close();

            return handler.getPersons();

        } catch (Exception e) {

            e.printStackTrace();

        }

        return null;
    }
</code></pre>

<p>分别点击三个按钮用不同方法解析出来的结果：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/291210425004835.png" alt="image" /></p>

<h2>三、总结</h2>

<p>　　对于三种解析XML方法，各有千秋，倾向于PULL解析器，因为SAX解析器操作起来太笨重，DOM不适合文档较大，内存较小的场景，
唯有Pull轻巧灵活，速度快，占用内存小，使用非常顺手，Pull解析可以用于很多场合，例如接受google天气，rss新闻等。</p>
]]></content>
  </entry>
  
</feed>
