<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: android | Chendd's Blog]]></title>
  <link href="http://chendd.github.io/tags/android/atom.xml" rel="self"/>
  <link href="http://chendd.github.io/"/>
  <updated>2016-07-29T11:45:42+08:00</updated>
  <id>http://chendd.github.io/</id>
  <author>
    <name><![CDATA[chendd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[编写高效的Android代码]]></title>
    <link href="http://chendd.github.io/blog/2013/05/15/efficient_android_code/"/>
    <updated>2013-05-15T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/05/15/efficient_android_code</id>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;为什么在这就意味着没有多少剩余空间给你去浪费了，因此，在你写Androi编写Android程序时要时刻考虑执行的效率，这些系统不是想象中的那么快，并且你还要考虑它电池的续航能力。写程序的时候，要尽可能的使你的代码优化而提高效率。</p>

<p>&#160; &#160; &#160; &#160;对于如何判断一个系统的不合理，这里有两个基本的原则：</p>

<h4>1、不要做不必要做的事情。</h4>

<h4>2、尽可能的节省内存的使用。</h4>

<!--more-->


<p>&#160; &#160; &#160; &#160;下面是常用的几点优化建议：</p>

<h4>1、尽可能避免创建对象（Object）</h4>

<p>&#160; &#160; &#160; &#160;因为对象的创建并不是没有代价的，如果你在一个用户界面的循环中分配一个对象，你不得不强制的进行内存回收，那么就会使用户体验出现稍微“打嗝”的现象。</p>

<p>&#160; &#160; &#160; &#160;当从原始的输入数据中提取字符串时，试着从原始字符串返回一个子字符串，而不是创建一份拷贝。</p>

<h4>2、使用自身方法（Use Native Methods）</h4>

<p>&#160; &#160; &#160; &#160;当处理字符串的时候，不要犹豫，尽可能多的使用诸如String.indexOf()、String.lastIndexOf()这样对象自身带有的方法。因为这些方法使用C/C++来实现的，
要比在一个java循环中做同样的事情快10-100倍。</p>

<h4>3、缓冲属性调用Cache Field Lookups</h4>

<p>&#160; &#160; &#160; &#160;访问对象属性要比访问本地变量慢得多。你不应该这样写你的代码：</p>

<pre><code class="java">for (int i = 0; i &lt; this.mCount; i++)
      dumpItem(this.mItems[i]);
</code></pre>

<p>&#160; &#160; &#160; &#160;而是应该这样写：</p>

<pre><code class="java">  int count = this.mCount;
  Item[] items = this.mItems;

  for (int i = 0; i &lt; count; i++)
      dumpItems(items[i]);
</code></pre>

<p>&#160; &#160; &#160; &#160;我们直接使用“this”表明这些是它的成员变量</p>

<h4>4、声明Final常量</h4>

<p>&#160; &#160; &#160; &#160;我们可以看看下面一个类顶部的声明：</p>

<pre><code class="java">static int intVal = 42;
static String strVal = "Hello, world!";
</code></pre>

<p>&#160; &#160; &#160; &#160;当一个类第一次使用时，编译器会调用一个类初始化方法，这个方法将42存入变量intVal，并且为strVal在类文件字符串常量表中提取一个引用，当这些值在后面引用时，就会直接属性调用。</p>

<p>&#160; &#160; &#160; &#160;我们可以用关键字“final”来改进代码：</p>

<pre><code class="java">static final int intVal = 42;
static final String strVal = "Hello, world!";
</code></pre>

<p>&#160; &#160; &#160; &#160;这个类将不会调用类初始化方法，因为这些常量直接写入了类文件静态属性初始化中，这个初始化直接由虚拟机来处理。代码访问intVal将会使用Integer类型的42，访问strVal将使用相对节省的“字符串常量”来替代一个属性调用。
将一个类或者方法声明为“final”并不会带来任何的执行上的好处，它能够进行一定的最优化处理。例如，如果编译器知道一个Get方法不能被子类重载，那么它就把该函数设置成Inline。</p>

<h4>5、避免浮点类型的使用</h4>

<p>&#160; &#160; &#160; &#160;嵌入式的处理器通常并不支持浮点数的处理，因此所有的“float”和“double”操作都是通过软件进行的，一些基本的浮点数的操作就需要花费毫秒级的时间。同时，即使是整数，一些芯片也只有乘法而没有除法。在这些情况下，整数的除法和取模操作都是通过软件实现。</p>

<h4>6、避免列举类型Avoid Enums</h4>

<p>&#160; &#160; &#160; &#160;列举类型非常好用，当考虑到尺寸和速度的时候，就会显得代价很高，例如：</p>

<pre><code class="java">public class Foo {
   public enum Shrubbery { GROUND, CRAWLING, HANGING }
}
</code></pre>

<p>&#160; &#160; &#160; &#160;这会转变成为一个900字节的class文件（Foo$Shrubbery.class）。第一次使用时，类的初始化要在独享上面调用方法去描述列举的每一项，每一个对象都要有它自身的静态空间，整个被储存在一个数组里面（一个叫做“$VALUE”的静态数组）。那是一大堆的代码和数据，仅仅是为了三个整数值。Shrubbery shrub = Shrubbery.GROUND;这会引起一个静态属性的调用，如果GROUND是一个静态的Final变量，编译器会把它当做一个常数嵌套在代码里面。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android学习日记25--ANR和Hander消息机制]]></title>
    <link href="http://chendd.github.io/blog/2013/03/30/android_study_25/"/>
    <updated>2013-03-30T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/03/30/android_study_25</id>
    <content type="html"><![CDATA[<h4>1、ANR(Application Not Responding)定义</h4>

<p>　　在Android上，如果你的应用程序有一段时间响应不够灵敏，系统会向用户显示一个对话框，
这个对话框称作应用程序无响应（ANR：Application Not Responding）对话框。用户可以选择“等待”而让程序继续运行，
也可以选择“强制关闭”。所以一个流畅的合理的应用程序中不能出现anr，而让用户每次都要处理这个对话框。
因此，在程序里对响应性能的设计很重要，这样系统不会显示ANR给用户。默认情况下，在android中Activity的最长执行时间是5秒，
BroadcastReceiver的最长执行时间则是10秒。</p>

<!--more-->


<p><img src="http://images.cnitblog.com/i/602984/201404/172223300108690.jpg" alt="image" /></p>

<h4>2、如何避免ANR</h4>

<p>&#160; &#160; &#160; &#160;Android应用程序通常是运行在一个单独的UI主线程里，因此，运行在主线程里的任何方法都尽可能少做事情。
特别是，Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。
潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里
（或者以数据库操作为例，通过异步请求的方式）来完成。然而，不是说你的主线程阻塞在那里等待子线程的完成——也不是调用
Thread.wait()或是Thread.sleep()。替代的方法是，主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。</p>

<h4>3、Hander 定义</h4>

<p>&#160; &#160; &#160; &#160;主要接受子线程发送的数据, 并用此数据配合主线程更新UI.
直接在UI线程中开启子线程来更新TextView显示的内容，运行程序我们会发现，如下错误：</p>

<pre><code>android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.
</code></pre>

<p>&#160; &#160; &#160; &#160;翻译过来就是：只有创建这个控件的线程才能去更新该控件的内容。
所有的UI线程要去负责View的创建并且维护它，例如更新冒个TextView的显示，都必须在主线程中去做，我们不能直接在UI线程中去创建子线程，
要利用消息机制：handler，如下就是handler的简单工作原理图:</p>

<p><img src="http://images.cnitblog.com/i/602984/201404/181859021979455.gif" alt="image" /></p>

<p>&#160; &#160; &#160; &#160;Android系统中的Looper负责管理线程的消息队列和消息循环。创建的工作线程默认是没有消息队列和消息循环的，如果想让工作线程具有消息队列和消息循环，</p>

<p>&#160; &#160; &#160; &#160;就需要在线程中先调用Looper.prepare()来创建消息队列，然后调用Looper.loop()进入消息循环。下面是我们创建的工作线程：</p>

<pre><code class="java">class WorkThread extends Thread {
          public Handler mHandler;

          public void run() {
              Looper.prepare();

              mHandler = new Handler() {
                  public void handleMessage(Message msg) {
                      // 处理收到的消息
                  }
              };

              Looper.loop();
          }
      }
</code></pre>

<p>&#160; &#160; &#160; &#160;这样一来，我们创建的工作线程就具有了消息处理机制了。运行在主线程中，Android系统会在Activity启动时为其创建一个消息队列和消息循环，就不需要</p>

<p>Looper.prepare()和Looper.loop();</p>

<h4>4、Hander 用法</h4>

<p>&#160; &#160; &#160; &#160;继承或实现Hendler类，并重写handleMessage(Message msg) 方法, 用于接受线程数据
如下实例：</p>

<p>&#160; &#160; &#160; &#160;启动后，更新后的值一直在增加</p>

<p><img src="http://images.cnitblog.com/i/602984/201404/172206262912209.png" alt="image" /></p>

<p>主要代码：</p>

<pre><code class="java">public class MainActivity extends Activity {

    private TextView tv;
    private static final int UPDATE = 0;
    private Handler handler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            // TODO 接收消息并且去更新UI线程上的控件内容
            if (msg.what == UPDATE) {
                // Bundle b = msg.getData();
                // tv.setText(b.getString("num"));
                tv.setText(String.valueOf(msg.obj));
            }
            super.handleMessage(msg);
        }
    };

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        tv = (TextView) findViewById(R.id.tv);

        new Thread() {
            @Override
            public void run() {
                // TODO 子线程中通过handler发送消息给handler接收，由handler去更新TextView的值
                try {
                    for (int i = 0; i &lt; 100; i++) {
                        Thread.sleep(500);
                        Message msg = new Message();
                        msg.what = UPDATE;
                        // Bundle b = new Bundle();
                        // b.putString("num", "更新后的值：" + i);
                        // msg.setData(b);
                        msg.obj = "更新后的值：" + i;
                        handler.sendMessage(msg);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();
    }

}
</code></pre>

<p>&#160; &#160; &#160; &#160;关于message，指对于Android中Handler可以传递一些内容，通过Bundle对象可以封装String、Integer以及Blob二进制对象，
我们通过在线程中使用Handler对象的sendEmptyMessage或sendMessage方法来传递一个Bundle对象到Handler处理器。
对于Handler类提供了重写方法handleMessage(Message msg) 来判断，通过msg.what来区分每条信息。
将Bundle解包来实现Handler类更新UI线程中的内容实现控件的刷新操作。相关的Handler对象有关消息发送sendXXXX相关方法如下，
同时还有postXXXX相关方法，这些和Win32中的道理基本一致，一个为发送后直接返回，一个为处理后才返回。</p>

<p>&#160; &#160; &#160; &#160;比如我们可以在message里封装Bundle对象。</p>

<p>&#160; &#160; &#160; &#160;两边传递的代码如下：</p>

<pre><code class="java">// 其他Thread里发送
Message msg = new Message();
Bundle b = new Bundle();// 存放数据
b.putString("color", "我的");
msg.setData(b);

// handleMessage里接收
Bundle b = msg.getData();
String color = b.getString("color");
</code></pre>

<h4>5、单线程的消息机制</h4>

<p>&#160; &#160; &#160; &#160;Hander属于多线程的消息机制，Android 单线程事件处理机制 有两种</p>

<ul>
<li>1、基于监听器的机制</li>
</ul>


<p>　　绑定特定的事件监听器，如Button的OnClickListener监听器， 监听器模型:包含事件源(EventSource)、事件(Event)、事件监听器(EventListener)。 一般内部类作为事件监听器类，主要因为 内部类可以在当前类复用;内部类可以调用外部类的组件。当然如果多个 GUI公用一个监听器类，还是使用外部类好一点，只需传入当前的context。当然大部分时间处理没什么复用价值， 更多的时候使用内部匿名类来实现。</p>

<ul>
<li>2、基于回调函数的机制</li>
</ul>


<p>　　重写回调方法，如View的OnKeyDown方法，基于回调函数的机制的事件源和事件监听器是统一的， Android为所有GUI提供一套事件处理方法，当重写回调函数处理完后必需返回true，事件才不会继续向上层调用。</p>

<p>&#160; &#160; &#160; &#160;优劣：基于回调函数 使得更具通用型、代码更加简洁， 基于回调函数 事件模型分工明确、具有更好的维护性 对于特定事件，无法使用回调函数只能使用监听器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android学习日记24--菜单开发]]></title>
    <link href="http://chendd.github.io/blog/2013/03/30/android_study_24/"/>
    <updated>2013-03-30T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/03/30/android_study_24</id>
    <content type="html"><![CDATA[<p>　　菜单是任何应用程序必不可少的一项。按下Menu键或者长按某个View就会弹出相应菜单，当然前提是应用程序有实现菜单功能。
Android平台下的菜单有：Options Menu(选项菜单)、Submenu(子菜单)、Context Menu(上下文菜单)。
这次的案例用以前的索尼真机测试，就不贴代码和运行截图，主要贴些理论知识。菜单这块比较简单，代码实例看<a href="http://www.cnblogs.com/giuz/archive/2010/10/19/1855235.html">这里</a></p>

<!--more--> 


<h2>一、选项菜单和子菜单</h2>

<p>　　Options Menu和Submenu 是一组的，放在一起介绍，一般用于开发普通的选项菜单。</p>

<p>相关回调方法及说明：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292323410312532.png" alt="image" /></p>

<p>涉及到相关类详解：</p>

<h4>1、Menu类</h4>

<p>　　一个Menu对象代表一个菜单，Menu对象中可以添加菜单项MenuItem，也可以添加子菜单SubMenu。常用方法如下:</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292324064696628.png" alt="image" /></p>

<p>注意：clear() 方法用于清除已添加的菜单，通过代码运行中的clear()再add()可以用于动态配置菜单。</p>

<h4>2、MenuItem类</h4>

<p>　　一个MenuIten对象代表一个菜单项，通常MenuItem实例通过Menu的add方法获得。常用方法如下：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292325371093303.png" alt="image" /></p>

<p>注意：Android最多支持6个MenuItem，多了以后就摆在More里面。</p>

<h4>3、SubMenu类</h4>

<p>　　一个SubMenu对象代表一个子菜单，可以理解为菜单的菜单，即Menu对象点进去弹出来的就叫子菜单，每个SubMenu实例代表一个子菜单，常用的方法如下</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292326297037235.png" alt="image" /></p>

<p>一般用法：</p>

<ul>
<li>1、在主Activity中覆盖onCreateOptionsMenu(Menu menu)方法,子菜单也在这里添加</li>
<li>2、如果要添加点击事件，则要覆盖onOptionsItemSelected(MenuItem item)方法</li>
</ul>


<h2>二、上下文菜单</h2>

<p>　　Context Menu类似于电脑上的右键，长按某个View之后弹出来的菜单。也是继承自Menu，不同于选项菜单，
选项菜单服务于Activity，而上下文是注册到某个VIew对象上的。如果一个View对象注册了上下文菜单，用户可以通过长按两秒该View对象调出上下文菜单。</p>

<p>用法同普通菜单，方法名称由Options替换Context</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/292327403289825.png" alt="image" /></p>

<h2>三、用XML配置菜单</h2>

<p>　　注意到新建项目的MainActivity 都会重写onCreateOptionsMenu方法
里面代码：
getMenuInflater().inflate(R.menu.main, menu);
就是通过XML来设置菜单的。</p>

<p>如下在res/menu/main.xml 就是本来的配置菜单</p>

<pre><code class="xml">&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" &gt;

    &lt;item
        android:id="@+id/action_settings"
        android:orderInCategory="100"
        android:showAsAction="never"
        android:title="@string/action_settings"/&gt;

&lt;/menu&gt;
</code></pre>

<p>其他同再JAVA代码里的写法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android学习日记23--XML解析]]></title>
    <link href="http://chendd.github.io/blog/2013/03/29/android_study_23/"/>
    <updated>2013-03-29T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/03/29/android_study_23</id>
    <content type="html"><![CDATA[<h2>一、简述</h2>

<p>　　XML语言是跨平台，JAVA对XML语言支持得比较好，android系统的应用层平台是JAVA做的，所以用XML。
XML解析比较简单。XML解析就是将获取到的数据分离出来，基本的网络数据传输，需要使用XML
比如天气预报，从网上获取的是XML文件，通过XML解析可以把天气状态读出来
例：</p>

<pre><code class="xml">&lt;forecast_date data="2009-07-31" /&gt;
&lt;condition data="晴" /&gt;
&lt;humidity data="湿度： 65%" /&gt;
</code></pre>

<p>可得到 2009-07-31 晴 湿度：65%</p>

<p>还有一作用是保存你的数据，比如做个旅游网站，你需要把全国各个省、城市名称写到XML文件进行保存，在程序中通过解析读取调用。</p>

<!--more-->


<p>Android 平台上可用的XML解析有三种</p>

<ul>
<li>1、Simple API for XML(SAX)</li>
<li>2、Document Object Model(DOM)</li>
<li>3、Android附带的pull解析器</li>
</ul>


<h2>二、实例</h2>

<p>分别用三种方法解析如下persons.xml文件（文件放在assert目录下）</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persons&gt;
    &lt;person id="23"&gt;
        &lt;name&gt;liming&lt;/name&gt;
        &lt;age&gt;30&lt;/age&gt;
    &lt;/person&gt;
    &lt;person id="20"&gt;
        &lt;name&gt;dehua&lt;/name&gt;
        &lt;age&gt;25&lt;/age&gt;
    &lt;/person&gt;
&lt;/persons&gt;
</code></pre>

<p>还需定义个javabean 用于存放解析出来的内容</p>

<pre><code class="java">package com.example.xml;

public class Person {
    private Integer id;
    private String name;
    private Short age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Short getAge() {
        return age;
    }

    public void setAge(Short age) {
        this.age = age;
    }

//    @Override
//    public String toString() {
//        return "id:" + id + ", name:" + name + ", age:" + age;
//    }
}
</code></pre>

<h4>1、Simple API for XML(SAX)</h4>

<p>　　SAX是一个解析速度快并且占用内存少的XML解析器，很适合用于Android等移动设备。
SAX解析XML文件采用的是事件驱动，也就是说，它并不需要解析完整个文档，在按内容顺序解析文档的过程中，
SAX会判断当前读到的字符是否合法XML语法中的某部分，如果符合就会触发事件。所谓事件，其实就是一些回调（callback）方法，
这些方法(事件)定义在ContentHandler接口。</p>

<p>　　直接看代码:</p>

<pre><code class="java">public class XMLContentHandler extends DefaultHandler {
    private List&lt;Person&gt; persons = null;
    private Person currentPerson;
    private String tagName = null;// 当前解析的元素标签    
    private static final String TAG = "XMLContentHandler"; 

    public List&lt;Person&gt; getPersons() {
        return persons;
    }

    /* 
     * 接收文档的开始的通知。
     */

    @Override
    public void startDocument() throws SAXException {
        persons = new ArrayList&lt;Person&gt;();
         Log.i(TAG, "startDocument");  
    }

    /* 
     * 结束文档的开始的通知。
     */

    @Override
    public void endDocument() throws SAXException {
        super.endDocument();
         Log.i(TAG, "endDocument");  
    }

    /* 
     * 接收字符数据的通知。
     */

    @Override
    public void characters(char[] ch, int start, int length)
            throws SAXException {
        if (tagName != null) {
            String data = new String(ch, start, length);
            if (tagName.equals("name")) {
                this.currentPerson.setName(data);
            } else if (tagName.equals("age")) {
                this.currentPerson.setAge(Short.parseShort(data));
            }
        }
        Log.i(TAG, "characters("+ch.toString()+","+start+","+length+")"); 

    }

    /*
     * 
     * 接收元素开始的通知。
     * 参数意义如下： 
     * namespaceURI：元素的命名空间 
     * localName ：元素的本地名称（不带前缀） 
     * qName ：元素的限定名（带前缀）
     * atts ：元素的属性集合
     */

    @Override
    public void startElement(String namespaceURI, String localName,
            String qName, Attributes atts) throws SAXException {

        if (localName.equals("person")) {
            currentPerson = new Person();
            currentPerson.setId(Integer.parseInt(atts.getValue("id")));
        }

        this.tagName = localName;
        Log.i(TAG, "startElement("+namespaceURI+","+localName+","+qName+atts+")"); 

    }

    /* 
     * 接收文档的结尾的通知。
     * 参数意义如下：
     * uri ：元素的命名空间
     * localName ：元素的本地名称（不带前缀）
     * name ：元素的限定名（带前缀）
     */
    @Override
    public void endElement(String uri, String localName, String name)
            throws SAXException {

        if (localName.equals("person")) {
            persons.add(currentPerson);
            currentPerson = null;
        }

        this.tagName = null;
        Log.i(TAG, "endElement("+uri+","+localName+","+name+")"); 

    }
}
</code></pre>

<h4>2、Document Object Model(DOM)</h4>

<p>　　DOM解析XML文件时，会将XML文件的所有内容读取到内存中，然后允许您使用DOM API遍历XML树、检索所需的数据。
使用DOM操作XML的代码看起来比较直观，并且，在某些方面比基于SAX的实现更加简单。但是，因为DOM需要将XML文件的所有内容读取到内存中，
所以内存的消耗比较大，特别对于运行Android的移动设备来说，因为设备的资源比较宝贵，所以建议还是采用SAX来解析XML文件，
当然，如果XML文件的内容比较小采用DOM是可行的。</p>

<pre><code class="java">public class DomParseXML {

    public List&lt;Person&gt; readXML(InputStream inStream) {

        List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();// 获取实例

        try {

            DocumentBuilder builder = factory.newDocumentBuilder();
            Document dom = builder.parse(inStream);
            Element root = dom.getDocumentElement();
            NodeList items = root.getElementsByTagName("person");// 查找所有person节点

            for (int i = 0; i &lt; items.getLength(); i++) {

                Person person = new Person();

                // 得到第一个person节点
                Element personNode = (Element) items.item(i);

                // 获取person节点的id属性值
                person.setId(new Integer(personNode.getAttribute("id")));

                // 获取person节点下的所有子节点(标签之间的空白节点和name/age元素)
                NodeList childsNodes = personNode.getChildNodes();

                for (int j = 0; j &lt; childsNodes.getLength(); j++) {

                    Node node = (Node) childsNodes.item(j); // 判断是否为元素类型
                    if (node.getNodeType() == Node.ELEMENT_NODE) {
                        Element childNode = (Element) node;

                        // 判断是否name元素
                        if ("name".equals(childNode.getNodeName())) {

                            // 获取name元素下Text节点,然后从Text节点获取数据
                            person.setName(childNode.getFirstChild()
                                    .getNodeValue());

                        } else if ("age".equals(childNode.getNodeName())) {
                            person.setAge(new Short(childNode.getFirstChild()
                                    .getNodeValue()));

                        }
                    }
                }
                persons.add(person);
            }
            inStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return persons;

    }
}
</code></pre>

<h4>3、Android附带的pull解析器</h4>

<p>　　Pull解析和Sax解析很相似，都是轻量级的解析，在Android的内核中已经嵌入了Pull，所以我们不需要再添加第三方jar包来支持Pull。
Pull解析和Sax解析不一样的地方有(1)pull读取xml文件后触发相应的事件调用方法返回的是数字(2)pull可以在程序中控制想解析到哪里就可以停止解析。</p>

<pre><code class="java">public class PullParseXML {

    public List&lt;Person&gt; readXML(InputStream inStream) throws XmlPullParserException, IOException{

        List&lt;Person&gt; persons = null;  
        Person person = null;  
        XmlPullParser parser = Xml.newPullParser();  
        parser.setInput(inStream, "UTF-8");  

        int event = parser.getEventType();//产生第一个事件  
        while(event!=XmlPullParser.END_DOCUMENT){  
            switch(event){  
            case XmlPullParser.START_DOCUMENT://判断当前事件是否是文档开始事件  
                persons = new ArrayList&lt;Person&gt;();//初始化Persons集合  
                break;  
            case XmlPullParser.START_TAG://判断当前事件是否是标签元素开始事件  
                if("person".equals(parser.getName())){//判断开始标签元素是否是person  
                    person = new Person();  
                    person.setId(Integer.parseInt(parser.getAttributeValue(0)));//得到Person标签的属性值，并设置Person的id  
                }  
                if(person!=null){  
                    if("name".equals(parser.getName())){//判断开始标签元素是否是name  
                        person.setName(parser.nextText());  
                    }else if("age".equals(parser.getName())){//判断开始标签元素是否是price  
                        person.setAge(Short.parseShort(parser.nextText()));  
                    }  
                }  
                break;  
            case XmlPullParser.END_TAG://判断当前事件是否是标签元素结束事件  
                if("person".equals(parser.getName())){//判断结束标签元素是否是Person  
                    persons.add(person);//将person添加到persons集合  
                    person = null;  
                }  
                break;  
            }  
            event = parser.next();//进入下一个元素并触发相应事件  
        }//end while  
        return persons;  

    }
}
</code></pre>

<p>运行界面：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/291207400008256.png" alt="image" /></p>

<p>绑定按钮触发的事件代码:</p>

<pre><code class="java">@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        textView = (TextView)findViewById(R.id.textView);  
        sax_prase = (Button)findViewById(R.id.sax_prase);  
        dom_parse = (Button)findViewById(R.id.dom_parse);  
        pull_parse = (Button)findViewById(R.id.pull_parse);


        try {
            inStream = getAssets().open("persons.xml");
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        //绑定按钮监听器  
        sax_prase.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                persons = SaxParseXML(inStream); 
                for (Person person : persons) {  
                    Log.i(TAG, person.getId()+":"+person.getName()+":"+person.getAge()); 
                } 
            }  
        });  
        //绑定按钮监听器  
        dom_parse.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  

                DomParseXML domParseXML = new DomParseXML();            
                persons = domParseXML.readXML(inStream);
                for (Person person : persons) {  
                    Log.i(TAG, person.getId()+":"+person.getName()+":"+person.getAge()); 
                } 
            }  
        });  
        pull_parse.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  

                PullParseXML pullParseXML = new PullParseXML();                             
                try {
                    persons = pullParseXML.readXML(inStream);
                } catch (XmlPullParserException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                for (Person person : persons) {  
                    Log.i(TAG, person.getId()+":"+person.getName()+":"+person.getAge()); 
                } 

            }  
        });
    }

    private static List&lt;Person&gt; SaxParseXML(InputStream inStream) {
        // TODO Auto-generated method stub
        try {
            SAXParserFactory spf = SAXParserFactory.newInstance();
            SAXParser saxParser = spf.newSAXParser(); // 创建解析器

            // 设置解析器的相关特性，http://xml.org/sax/features/namespaces = true
            // 表示开启命名空间特性,缺省情况设为true，设置使代码更具可读性,但我加进去报错，索性注释掉
            //saxParser.setProperty("http://xml.org/sax/features/namespaces",true);
            XMLContentHandler handler = new XMLContentHandler();

            saxParser.parse(inStream, handler);
            inStream.close();

            return handler.getPersons();

        } catch (Exception e) {

            e.printStackTrace();

        }

        return null;
    }
</code></pre>

<p>分别点击三个按钮用不同方法解析出来的结果：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/291210425004835.png" alt="image" /></p>

<h2>三、总结</h2>

<p>　　对于三种解析XML方法，各有千秋，倾向于PULL解析器，因为SAX解析器操作起来太笨重，DOM不适合文档较大，内存较小的场景，
唯有Pull轻巧灵活，速度快，占用内存小，使用非常顺手，Pull解析可以用于很多场合，例如接受google天气，rss新闻等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android学习日记22--Animation动画简介]]></title>
    <link href="http://chendd.github.io/blog/2013/03/26/android_study_22/"/>
    <updated>2013-03-26T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2013/03/26/android_study_22</id>
    <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;Animation动画主要有两种：帧动画(Frame Animation)和补间动画(Tween Animation)。
补间动画主要包括对位置、角度、尺寸等属性的变化，而帧动画则是通过若干帧图片轮流切换显示的。</p>

<h4>1、帧动画</h4>

<p>&#160; &#160; &#160; &#160;按顺序显示事先准备好的图片，跟动漫类似。主要用到的类AnimationDrawable，每个帧都是AnimationDrawable对象。
定义帧动画可以在代码直接进行。也可以通过XML文件定义，定义帧动画的文件存放在res/anim目录下。XML指定帧出现的顺序
及每个帧的持续时间。</p>

<!--more-->


<p>&#160; &#160; &#160; &#160;帧动画XML主要标记和属性如下:</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/262025574051823.png" alt="image" /></p>

<p>&#160; &#160; &#160; &#160;需要强调的是：启动Frame Animation动画的代码rocketAnimation.start();不能在OnCreate()中，因为在OnCreate()中
AnimationDrawable还没有完全的与ImageView绑定，在OnCreate()中启动动画，就只能看到第一张图片。这里实在拖曳事件中实现的。</p>

<p>&#160; &#160; &#160; &#160;AnimationDrawable的主要方法如下：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/262028348437192.png" alt="image" />
　　</p>

<p>&#160; &#160; &#160; &#160;帧动画使用例子</p>

<p>&#160; &#160; &#160; &#160;完整帧动画XML(frame_ani.xml)代码：</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
 &lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"
     android:oneshot="false"&gt;
    &lt;item android:drawable="@drawable/fish1" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish1" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish2" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish3" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish4" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish5" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish6" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish7" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish8" android:duration="200" android:visible="true"/&gt;
    &lt;item android:drawable="@drawable/fish8" android:duration="200" android:visible="true"/&gt;
 &lt;/animation-list&gt;
</code></pre>

<p>启动帧动画JAVA代码：</p>

<pre><code class="java">@Override    
public void onClick(View v) {            //重写onClick方法
      ImageView iv = (ImageView)findViewById(R.id.iv);
      iv.setBackgroundResource(R.anim.frame_ani);
      AnimationDrawable ad = (AnimationDrawable)iv.getBackground();
      ad.start();        //启动AnimationDrawable
}
</code></pre>

<p>点击按钮，启动帧动画，可以看见不同fish图片的切换，鱼儿在游动(自己脑补哈)。</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/262029485935994.png" alt="image" /></p>

<h4>2、补间动画</h4>

<p>&#160; &#160; &#160; &#160;补间动画作用于View视图，主要包括对View对象的位置、尺寸、旋转角度、透明度的变化。补间动画涉及的类主要有Animation、AnimationSet等。
&#160; &#160; &#160; &#160;补间动画同帧动画可以在代码直接进行。也可以通过XML文件定义，推荐用XML，因为这样可读性比较高和利于扩展。
XML文件存放在res/anim下。</p>

<p>　　补间动画XML几种变化标记和属性如下:</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/262034318435727.png" alt="image" /></p>

<p>　　公有属性如下：</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/262034454364374.png" alt="image" />　</p>

<p>　　补间动画使用例子：</p>

<p>完整补间动画XML代码：</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!-- XML的版本以及编码方式 --&gt;
&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; 
  &lt;alpha
    android:fromAlpha="0.0" 
    android:toAlpha="1.0" 
    android:duration="6000" 
  /&gt; &lt;!-- 透明度的变换 --&gt;
  &lt;scale
    android:interpolator= "@android:anim/accelerate_decelerate_interpolator" 
    android:fromXScale="0.0" 
    android:toXScale="1.0" 
    android:fromYScale="0.0" 
    android:toYScale="1.0" 
    android:pivotX="50%" 
    android:pivotY="50%"
    android:fillAfter="false" 
    android:duration="9000"
  /&gt; &lt;!-- 尺寸的变换 --&gt;
  &lt;translate
    android:fromXDelta="30" 
    android:toXDelta="0" 
    android:fromYDelta="30"
    android:toYDelta="0" 
    android:duration="10000" 
  /&gt; &lt;!-- 尺位置的变换 --&gt;
  &lt;rotate
    android:interpolator="@android:anim/accelerate_decelerate_interpolator" 
    android:fromDegrees="0" 
    android:toDegrees="+360" 
    android:pivotX="50%" 
    android:pivotY="50%"
    android:duration="10000"
  /&gt; &lt;!-- 旋转变换 --&gt;
&lt;/set&gt;
</code></pre>

<p>启动补间动画JAVA代码:</p>

<pre><code class="java">@Override
public void onClick(View v) {                //重写onClick方法
       ImageView iv = (ImageView)findViewById(R.id.iv);
       Animation animation = AnimationUtils.loadAnimation(MainActivity.this, R.anim.tween_ani);
       iv.startAnimation(animation);            //启动动画            
}
</code></pre>

<p>点击按钮，启动补间动画，可以看见螃蟹从中心慢慢旋转显现出来。</p>

<p><img src="http://images.cnitblog.com/i/602984/201403/262039309214990.png" alt="image" /><img src="http://images.cnitblog.com/i/602984/201403/262039459996150.png" alt="image" /></p>
]]></content>
  </entry>
  
</feed>
