<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 细节 | Chendd's Blog]]></title>
  <link href="http://chendd.github.io/tags/xi-jie/atom.xml" rel="self"/>
  <link href="http://chendd.github.io/"/>
  <updated>2016-07-28T12:00:22+08:00</updated>
  <id>http://chendd.github.io/</id>
  <author>
    <name><![CDATA[chendd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[android学习日记4--开发中的通用细节]]></title>
    <link href="http://chendd.github.io/blog/2014/02/19/android_study_04/"/>
    <updated>2014-02-19T21:32:12+08:00</updated>
    <id>http://chendd.github.io/blog/2014/02/19/android_study_04</id>
    <content type="html"><![CDATA[<h4>1、android中的计量单位</h4>

<ul>
<li>px （pixels）（像素）：是屏幕的物理像素点，与密度相关，密度大了，单位面积上的px会比较多。通常不推荐使用这个</li>
<li>pt(磅):1/72英寸,也较少用</li>
<li>in(英寸):标准长度单位</li>
<li>mm(毫米):标准长度单位</li>
</ul>


<!--more-->


<p>&#160; &#160; &#160; &#160;布局中尽量用dip(dp):独立像素 做单位
　　字体中尽量用sp：放大像素 与刻度无关做单位</p>

<p>&#160; &#160; &#160; &#160;使用 dip: device independent pixels（设备独立像素）。显示效果因不同硬件设备而不同，为了支持WVGA、HVGA和QVGA
　　推荐使用dip(dp) px: pixels(像素). HVGA用px比较多。 pt: 1pt＝1/72英寸； sp: scaled pixels(放大像素)。
　　主要用于字体显示best for textsize。</p>

<h4>2、屏幕大小</h4>

<ul>
<li><p>VGA 分辨率为480*640像素</p></li>
<li><p>HVGA 分辨率为320*480像素，全称是Half VGA</p></li>
<li><p>QVGA 分辨率为240*320像素，全称是Quarter VGA</p></li>
<li><p>WVGA 分辨率为240<em>400像素，全称是Wide Quarter VGA WVGA 分辨率达到了480</em>800像素或者480*854（宽屏）像素，全称是Wide VGA</p></li>
<li><p>WQVGA (Wide QVGA) 是对QVGA320X240分辨率的扩展, 达到400X240( 或者480X272)分辨率; 是支持16:9的宽屏应用的.</p></li>
</ul>


<h4>3、屏幕适配方法</h4>

<p>&#160; &#160; &#160; &#160;ppi（pixel per inch），翻译过来就是每英寸的距离像素点的个数。对于一张200x200像素的图片，我国我们想要显示在 200ppi 的手机上，那么占用屏幕的长和宽均为   200pix  /  (200pix / inch) = 1 inch  ,也就是说要占用 1 inch x 1 inch,如果要显示在 300ppi 的手机上，那么占用屏幕的长和宽均为  200pix  / (300pix / inch )  = 2/3 inch，也就是说对于 ppi越高的手机，单位inch上能够显示更多的像素点，因此当这两种手机显示同样多的像素点的时候，ppi 越高的手机占用的空间就越小。这就是我们想要图片在各种手机屏幕上都显示一致的效果时需要解决的问题。　</p>

<p>&#160; &#160; &#160; &#160;drawable-ldpi、drawable-mdpi、drawable-hdpi、drawable-xhdpi，drawable-xxhdpi,这几个目录对应的pppi为</p>

<p>120ppi  160ppi   240ppi    320ppi   480ppi ，也就是说如果屏幕的ppi为320，那么就会优先使用drawable-xhdpi目录下的</p>

<p>图片资源。当然手机屏幕的ppi也是多种多样，例如有的是  300ppi，有的是220ppi，这个系统会选择最接近的目录</p>

<ul>
<li><p>方法一：对每一中不同的ppi使用不同的图片，这需要我们先判断屏幕的ppi，再对图片进行处理，然后显示，显然比较麻烦。而且对于获取屏幕ppi这个参数android并没有提供给我们api调用。所以这种办法基本行不通</p></li>
<li><p>方法二:  在用eclipse开发环境生成一个android项目后，系统会给我们生成drawable-ldpi、drawable-mdpi、drawable-hdpi、drawable-xhdpi，drawable-xxhdpi,对于同一张图片资源，我们分别创建这五个版本来适应不同的屏幕。</p></li>
<li><p>方法三：方法2中需要为每个drawable目录都生成对应的图片版本，如果图片较多的话，生成不同版本的图片倒是小事更主要的缺点是会增大应用的大小，那么可不可以只在一个目录下存放图片，例如只在drawable-mdpi目录下存放图片呢答案是可以的，假设我们在drawable-hdpi（对应的ppi为160ppi）目录下存放了一个100X100的图片，那么当图片需要在320ppi的android设备上进行显示时，android系统会将自动将图片进行处理生成一个200X200的图片显示到设备上，那么他们占用的空间大小分别为  100/160  = 3/5  inch     200/320 = 3/5 inch  可以看出他们占用的长和宽都是一样的这种自动缩放的优点是只需要一张图片就能适应各种ppi类型的屏幕。缺点是当对100X100的图片进行变换成200X200的图片时肯能会造成图片的不清晰，如果提供一个drawable-xhdpi下的图片资源，图片较多的话会无形增加应用的大小，所以说如何进行选择也是一个衡量。建议是将比较重要的图片资源提供多个版本（当android设备和自己的ppi相对应的drawable下找到想要的资源时，就不会再到其他目录需找资源）。不是很重要的图片资源存储一个版本，让系统根据自己的ppi自己对图片进行适当的缩放显示。</p></li>
</ul>


<h4>4、Context</h4>

<p>&#160; &#160; &#160; &#160;Context是一个抽象类，它有很多子类，如Activity、TabActivity、Service等</p>

<p>&#160; &#160; &#160; &#160;位于android.content.Context中，其实该类为LONG型，类似Win32中的Handle句柄，很多方法需要通过 Context才能识别调用者的实例Context可以理解为句柄或上下文，主要用于加载或访问系统资源很多组件实例化都要传递它作为参数如 Toast，由于Activity是它的子类，所以直接传this即可，但是在内部类实现时一般 要传 ActivityName.this</p>

<h4>5、Resources</h4>

<p>&#160; &#160; &#160; &#160;android是一个平台，一个框架，这个框架包含许多资源，string、color、bitmap、style等resources。android的AAPT会自动为这些文件建立一个ID,在程序中就可以以使用这些ID来引用这些resources，如果你想改某个值，只需要修改这些resource而不需要修改源代码</p>

<p>&#160; &#160; &#160; &#160;Android 中的Resources都会由R.java生成ID自动管理
引用时只要 调用 getResources().getXX(ID)即可
XX表示res文件下的xml文件名;常用的有：</p>

<ul>
<li>res/drawable/ 用来存放图片文件</li>
<li>res/layout/ 用来存放布局定义文件</li>
<li>res/values/ 用来存放一些变量、参数等文件</li>
</ul>


<h4>6、R.java</h4>

<p>&#160; &#160; &#160; &#160;在R.java的注释部分， 有这样一段话：“AUTO-GENERATE FILE. DO NOT MODIFY”，这个文件是自动生成的，不要修改。
这个文件是在程序编译过程中由aapt(Android Asset Packaging Tool) 自动生成
这个文件中的属性都是public static final的，所以可以直接在Java代码中引用，每个属性都代表一个资源，看起来就像为每个资源都定义了一个ID，然后通过这个ID来访问资源
　　所有的资源文件都被编译进最后生成的二进制包中，这样能够带来很高的性能和效率</p>

<h4>7、findViewById</h4>

<p>&#160; &#160; &#160; &#160;通过ID来找到布局中的组件的方法。我们调用的findViewById()函数其实有两种（目前我只看到两种，不确定还有没有其他的），一种是Activity类中findViewById()函数。另外一种是View类中定义的findViewById()函数一般我们在oncreate()方法中使用的(XXview)findViewById(R.id.XX)既是调用的Activity中的findViewById()函数。而在其他情况写出的XXview.findViewById()中调用的是view类中的findViewById()</p>

<h4>8、LayoutInflate</h4>

<p>&#160; &#160; &#160; &#160;实例化xml布局文件中的布局，获取具体布局
一般有如下两种写法，但是本质是一样的</p>

<pre><code class="java">　　LayoutInflater inflater = LayoutInflater.from(this); 
　　View layout = inflater.inflate(R.layout.main, null);

　　LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE); 
　　View layout = inflater.inflate(R.layout.main, null);
</code></pre>
]]></content>
  </entry>
  
</feed>
